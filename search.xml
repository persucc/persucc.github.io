<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java-JVM内存管理</title>
      <link href="/2019/08/11/Java-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Java-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java内存分配不像C++一样，需要程序员自己手动回收内存，C++如果内存回收管理没处理好，会出现内存泄漏，野指针（指向一块随机内存空间，指向已经被删除的对象或者无访问权限的内存空间），而Java拥有自动回收机制的JVM，不需要程序员手动去管理内存空间。下面仔细探讨JVM是怎么回收。</p><a id="more"></a><p>JVM内存结构：</p><p>yy<br><img src="/.com//1.jpeg" alt="想输入的提示名字，可不输入"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc内存分配机制</title>
      <link href="/2019/08/09/malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/09/malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java文件处理</title>
      <link href="/2019/08/08/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2019/08/08/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java文件系统，包括目录，文件的创建，删除。读文件，写文件，java是采用数据流的形式来对文件进行读写</p><a id="more"></a><p>import java.io.*;<br>Java创建目录：<br>    File d = new File(“../../temp”);//路径../是返回上层，如果直接采用/temp则是在当前工程目录下创建<br>    if(!d.exists()) {<br>        d.mkdirs();//多级目录<br>        //d.mkdirs();单级目录<br>    }</p><p>Java创建文件：<br>    File f = new File(“../../temp/a.txt⁩”);<br>    //异常处理 try-catch<br>    if(!f.exists()) {<br>        try {<br>            f.createNewFile();//创建该文件（a.txt）<br>        }<br>        catch(Exception e) {<br>            e.printStackTrace();<br>        }</p><p>// 输出文件的相关属性<br>        System.out.println(“Is f file?” + f.isFile());<br>        System.out.println(“Name:” + f.getName());<br>        System.out.println(“Prarent:” + f.getParent());<br>        System.out.println(“Path:” + f.getPath());<br>        System.out.println(“Size:” + f.length() + “bytes”);<br>        System.out.println(“Last modified time:” + f.lastModified());</p><p>//目录，文件的删除<br>    f.delete();<br>    d.delete();</p><p>//写数据到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">OutputStreamWriter osw = null;</span><br><span class="line">BufferedWriter bw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    //节点类，负责写字节到文件</span><br><span class="line">    fos = new FileOutputStream(&quot;../../temp/a.txt&quot;);</span><br><span class="line">    //转化类，负责字符转化为字节</span><br><span class="line">    osw = new OutputStreamWriter(fos , &quot;UTF-8&quot;);</span><br><span class="line">    //装饰类，负责写字符到缓冲区</span><br><span class="line">    bw = new BufferedWriter(osw);</span><br><span class="line">    </span><br><span class="line">    bw.write(&quot;我们是&quot;);</span><br><span class="line">    //换行</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(&quot;Ecumers.^^&quot;);</span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //关闭自高层的类，底下流都会关闭</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//JDK7之后的try-resource语句，try语句结束后会自动关闭bw，更高效简洁</span><br><span class="line">try(BufferedWriter bw = </span><br><span class="line">new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;../../temp/b.txt&quot;))))&#123;</span><br><span class="line">bw.write(&quot;I am&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;ironman！&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    //读文件是只能逐行读取</span><br><span class="line">    public static void readFile() &#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    InputStreamReader isr = null;</span><br><span class="line">    BufferedReader br = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        fis = new FileInputStream(&quot;../../temp/a.txt&quot;);</span><br><span class="line">        isr = new InputStreamReader(fis , &quot;UTF-8&quot;);</span><br><span class="line">        br = new BufferedReader(isr);</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null)</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //关闭自高层的类，底下流都会关闭</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;catch(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void readFile2() &#123;</span><br><span class="line">    try(BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;../../temp/b.txt&quot;))))&#123;</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔笔记（2019.8.1）</title>
      <link href="/2019/08/01/note-19-8-1/"/>
      <url>/2019/08/01/note-19-8-1/</url>
      
        <content type="html"><![CDATA[<p>关于Java的List（列表），Set（集合），++a和a++的具体区别</p><a id="more"></a><p>List：<br>ArrayList（可变数组）：基于数组的数据结构，遍历最好采用随机索引和foreach去遍历。尽量少用add，会造成大部分元素的移动，时间复杂度为O(n)，少添加和删除。<br>LinkedList：基于双向链表的数据结构，遍历最好采用迭代器和foreach去遍历，可以用add，链表的添加和删除都是O(1)<br>Vector：类似于ArraList，多一个遍历方法Emuration（类似于iterator）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//三种遍历方式</span><br><span class="line">public static void traverseByIterator(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========迭代器遍历=========&quot;);</span><br><span class="line">    Iterator&lt;Integer&gt;iter1 = a1.iterator();</span><br><span class="line">    while(iter1.hasNext()) &#123;</span><br><span class="line">    iter1.next();</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void traverseByIndex(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========随机索引遍历=========&quot;);</span><br><span class="line">    for(int i=0;i &lt; a1.size();++i) &#123;</span><br><span class="line">    a1.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void traverseByFor(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========For循环遍历=========&quot;);</span><br><span class="line">    for(Integer item : a1) &#123;</span><br><span class="line">    ;</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Set：<br>HashSet和LinkedHashSet的判断是根据hashCode和equals来进行判别两个是否对象是否相等，而TreeSet必须通过实现comparable接口里面的compareTo方法，否则会报语法错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class cat&#123;</span><br><span class="line">private int size;</span><br><span class="line">cat(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">    HashSet&lt;cat&gt;hs = new HashSet&lt;cat&gt;();</span><br><span class="line">    hs.add(new cat(1));</span><br><span class="line">    hs.add(new cat(1));</span><br><span class="line">    System.out.println(hs.size());</span><br><span class="line">//输出2   </span><br><span class="line"></span><br><span class="line">class dog&#123;</span><br><span class="line">private int size;</span><br><span class="line">dog(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">System.out.println(&quot;Dog hashCode&quot;);</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">/*该方法的参数必须是Object类型，如果为dog类型虽然不会报错，但输出结果会为2，equals方法不会被调用*/</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">System.out.println(&quot;Dog equals&quot;);</span><br><span class="line">if(0 == size - ((dog)obj).getSize())</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">System.out.println(&quot;Dog toString&quot;);</span><br><span class="line">return size + &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">        LinkedHashSet&lt;dog&gt;hs2 = new LinkedHashSet&lt;dog&gt;();</span><br><span class="line">hs2.add(new dog(1));</span><br><span class="line">hs2.add(new dog(1));</span><br><span class="line">System.out.println(hs2.size());</span><br><span class="line">//输出1</span><br><span class="line"></span><br><span class="line">//tiger类实现Comparable接口中的compareTo()方法</span><br><span class="line">class tiger implements Comparable&#123;</span><br><span class="line">private int size;</span><br><span class="line">tiger(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int compareTo(Object obj) &#123;</span><br><span class="line">   return size - ((tiger)obj).getSize();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试，最后输出1</span><br><span class="line">        TreeSet&lt;tiger&gt; ts = new TreeSet&lt;tiger&gt;();</span><br><span class="line">ts.add(new tiger(1));</span><br><span class="line">ts.add(new tiger(1));</span><br><span class="line">System.out.println(ts.size());</span><br><span class="line"></span><br><span class="line">//如果写TreeSet&lt;dog&gt; ts = new TreeSet&lt;dog&gt;();会报语法错误</span><br></pre></td></tr></table></figure><p>a = 1：首先将常量1压入栈顶，后面将栈顶1弹出赋值给a，栈为空<br>a = a++：结果a = 1，因为a = a++是先将a的值1压入栈顶，再执行a+1操作，这时a的值为2，最后将栈顶的1弹出赋值给a，所以a=1；<br>a = ++a：结果a=2，因为a = ++a是先将a执行a+1操作，此时a等于，再将a的数值2压入栈顶，最后将2弹出并赋值给a，所以a=2</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="/2019/07/26/Dijkstra/"/>
      <url>/2019/07/26/Dijkstra/</url>
      
        <content type="html"><![CDATA[<p>单源最短路径：一个顶点到图中其它顶点的最短通路长度</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//顶点数为n，边数为m，该算法的时间复杂度为O(n^2)</span><br><span class="line">/*采用n*n矩阵存储数据,此代码是求顶点1到其他顶点的最短路，后面那个优化的是可以从任意顶点开始 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1e9</span><br><span class="line"></span><br><span class="line">static int Count = 2; //计数器判断算法结束</span><br><span class="line">int dis[10][10]; //矩阵存储数据</span><br><span class="line">bool flag[10] = &#123;0&#125;; //判断顶点是否已经访问过</span><br><span class="line">int range[10] = &#123;0&#125;;  // 存储源点到其他顶点的距离</span><br><span class="line">int res_record[10] = &#123;0,1,1,1,1,1,1,1,1,1&#125;; //记录从源点开始依次找到的点</span><br><span class="line"></span><br><span class="line">int MIN(int n)&#123;  //寻找最小距离的点</span><br><span class="line">    int t ;</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        if(flag[i]) continue;//所找到的点为已经找到的</span><br><span class="line">        else&#123;</span><br><span class="line">            t = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        if(range[t] &gt; range[i] &amp;&amp; !flag[i])&#123;</span><br><span class="line">            t = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">//点矩阵，距离矩阵的初始化</span><br><span class="line">void Init(int n)&#123;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">      dis[i][i] = MAX;</span><br><span class="line">   &#125; </span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       for(int j=1;j &lt; i ;++j)&#123;</span><br><span class="line">           cin &gt;&gt; dis[i][j];</span><br><span class="line">           dis[j][i] = dis[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">      range[i] = dis[1][i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> //每次找到一个点后对距离矩阵进行调整</span><br><span class="line">void Adjust(int i,int n)&#123;</span><br><span class="line">    for(int j=2;j &lt;= n;++j)&#123;</span><br><span class="line">        //判断依据是min(range[j],range[i]+dis[i][j])</span><br><span class="line">        if((!flag[j]) &amp;&amp; (range[j] &gt; range[i] + dis[i][j]))&#123;</span><br><span class="line">            //记录每个点的前驱</span><br><span class="line">           res_record[j] = i;</span><br><span class="line">           range[j] = range[i]+ dis[i][j];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int n)&#123;</span><br><span class="line">    while(Count &lt;= n)&#123;</span><br><span class="line">        //找到最小距离所对应的点</span><br><span class="line">        int t = MIN(n);</span><br><span class="line">        //判断该点是否以及被访问</span><br><span class="line">        if(!flag[t])&#123;</span><br><span class="line">           flag[t] = true;</span><br><span class="line">           Count++;</span><br><span class="line">           Adjust(t,n);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环查找最小距离所途经的点</span><br><span class="line">void find(int k)&#123;</span><br><span class="line">    int p = 0,t = 0;</span><br><span class="line">     while(k != 1)&#123;</span><br><span class="line">         range[t++] = k;</span><br><span class="line">         p += dis[k][res_record[k]];</span><br><span class="line">         k = res_record[k];</span><br><span class="line">     &#125;</span><br><span class="line">     range[t++] = 1;</span><br><span class="line">     for(int i=t-1;i &gt;= 1;--i)</span><br><span class="line">       cout &lt;&lt; range[i] &lt;&lt; &quot;--&gt;&quot;;</span><br><span class="line">       cout &lt;&lt; range[0] &lt;&lt; &quot;   &quot;&lt;&lt; &quot;距离:&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Init(n);</span><br><span class="line">    dijkstra(n);</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        find(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法还可以进行改进，主要是在求最小range最小距离时可以使用最小堆（优先队列），可使复杂度降为O(nlog(n)) 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//采用n*n矩阵存储数据 </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1e9</span><br><span class="line">//小根堆</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    bool operator &lt; (const node &amp;a)const&#123;</span><br><span class="line">        return x &gt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static int Count = 2;</span><br><span class="line">int dis[10][10]; //矩阵存储数据</span><br><span class="line">int res_record[10] = &#123;0,1,1,1,1,1,1,1,1,1&#125;; //记录从源点开始依次找到的点</span><br><span class="line">priority_queue&lt;node&gt;Q;//优先队列</span><br><span class="line">vector&lt;node&gt;v;</span><br><span class="line"></span><br><span class="line">//点矩阵，距离矩阵的初始化</span><br><span class="line">void Init(int n,int m)&#123;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">      dis[i][i] = MAX;</span><br><span class="line">   &#125; </span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       for(int j=1;j &lt; i ;++j)&#123;</span><br><span class="line">           cin &gt;&gt; dis[i][j];</span><br><span class="line">           dis[j][i] = dis[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       node a ;</span><br><span class="line">       a.x = dis[m][i];</span><br><span class="line">       a.y = i;</span><br><span class="line">       Q.push(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dijkstra(int n,int m)&#123;</span><br><span class="line">    while(Count &lt;= n)&#123;</span><br><span class="line">        //找到最小距离所对应的点</span><br><span class="line">        node a = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Count++;</span><br><span class="line">        while(!Q.empty())&#123;</span><br><span class="line">            node b = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            if(b.x &gt; a.x + dis[a.y][b.y])&#123;</span><br><span class="line">                b.x = a.x + dis[a.y][b.y];</span><br><span class="line">                res_record[b.y] = a.y;</span><br><span class="line">            &#125;</span><br><span class="line">            v.push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i &lt; v.size();++i)&#123;</span><br><span class="line">            Q.push(v[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        v.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环查找最小距离所途经的点</span><br><span class="line">void find(int k,int m)&#123;</span><br><span class="line">    int p = 0,t = 1;</span><br><span class="line">    int record[10] = &#123;0&#125;;</span><br><span class="line">    record[0] = k;</span><br><span class="line">     while(k != m)&#123;</span><br><span class="line">         p += dis[k][res_record[k]];</span><br><span class="line">         k = res_record[k];</span><br><span class="line">         record[t++] = k;</span><br><span class="line">     &#125;</span><br><span class="line">     for(int i=t-1;i &gt;= 1;--i)&#123;</span><br><span class="line">         cout &lt;&lt; record[i] &lt;&lt; &quot;--&gt;&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">        cout &lt;&lt; record[0] &lt;&lt; &quot; 距离:  &quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //n个顶点，从第m个点出发</span><br><span class="line">    int n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">        res_record[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    Init(n,m); </span><br><span class="line">    dijkstra(n,m);</span><br><span class="line">    for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">        if(m == i) continue;</span><br><span class="line">        find(i,m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2019/07/09/hello-world/"/>
      <url>/2019/07/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
