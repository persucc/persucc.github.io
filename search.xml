<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java-JVM内存管理</title>
      <link href="/2019/08/13/Java-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/13/Java-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java不像C++一样，需要程序员手动回收内存。所以当c++程序没有处理好内存回收，将会导致内存泄漏以及野指针（指针指向随机的内存空间，或者是以及删除的对象）等不良后果。Java拥有自动回收机制的JVM，所以对程序的安全性有很大保障。下面来讨论Java的JVM是怎么进行回收工作的。</p><a id="more"></a><p>一、JVM内存结构</p><img src="/2019/08/13/Java-JVM内存管理/1.jpeg" title="This is an image"><p>Java栈：<br>  Java栈是线程私有的，每个方法在执行的同时会创建一个栈。用于存储局部变量表，操作数栈，动态链接等信息。每一个方法调用到执行完成的过程，其实就是对应一个栈帧在虚拟机栈中入栈到出栈的过程<br>程序计数器：<br>  一块比较小的内存空间，可以看作是当前线程所执行的字节码行号指示，通俗的来说就是来指示下一条指令。因为Java的多线程是通过轮流切换来分配处理器的执行时间（表示一个时间段内只有一个线程是处于工作状态的），所以必须每个线程分配一个程序计数器，否则在线程频繁切换时，会导致线程不能正确的执行该线程的下一条指令。<br>Java堆：<br>  与Java栈不同的是，Java堆是所有线程共享的，用于存放对象的实例，几乎所有的对象都会在这里分配内存空间，从回收的角度看，Java堆可分为“新生代”和“老年带”。并且堆空间可以处于物理上的不连续空间，只需要逻辑上的连续即可。JDK1.6之前，字符串常量池位于方法区中，JDK1.7之后转移到Java堆。在Java虚拟机中实现字符串常量的是一个StringTable类，它的实质是一个Hash表。每个Java虚拟机中都只有一份这个Hash表，被所有的类共享。因此更多的数据要存放到堆中，导致堆大小要适配，所以更多的应用程序在堆中的使用差异更小。<br>方法区：<br>  方法区也是所有线程共享，它的主要功能存储虚拟机加载的类信息，常量和编译代码数据。方法区中有一个运行时常量池（注意不是字符串常量池），它存储的是类编译的各种字面量和符号引用。<br>     字面量：文本字符串，八种基本类型的值，final常量（表示成员变量只能被赋值一次，赋值后的值不再改变）<br>     符号引用：类和方法的全限定名（import org.apache.commons.lang3.StringUtils;boolean isEmpty = StringUtils.isNotEmpty(str)；） == （boolean isEmpty = org.springframework.util.StringUtils.isEmpty(str)/;）//全限定名，字段和方法的名称和描述符（static，final）</p><p>二、Java堆回收机制<br>垃圾回收主要考虑的问题有两个：一是效率问题，二是空间碎片问题<br>在前文中已经说过，Java堆有两个区域，“新生代”和“老年代”。新生代又分为三个部分，一个较大的Eden区域和两个Survivor区域。老年代就是一块大内存，没有分区但空间是零散的。因为新生代和老年代所存储的对象不同，为了把效率和碎片空间问题优化，所以两个区域采用不同的算法。<br>新生代-复制算法：<br>  新生代中主要存储比较新的对象，回收多次之后依然存活的对象会移动到老年代。由此可知新生代的垃圾回收比较频繁，复制算法可以将内存分为大小相同的两块，每次分配其中一块，当一块内存已满时，JVM将会对内存进行回收，将还存活的对象复制到其他一块内存，此时这块已满的内存就可以完全释放，不用担心碎片化的问题。这种算法的缺点是内存利用率较低，只能使用一般的内存进行分配。又因为有研究表明，新生代中的对象98%都会被释放，所以完全不用1:1的划分内存空间，所以最新的是将内存分为一块较大得Eden区和两块Survivor区。为什么需要两块Survivor呢，实质上是为了解决碎片化的问题，假定，只有一个Eden区，当该区满的时候，进行Gc（垃圾回收），存活对象放入Survivor区，清空Eden区，当第二次Gc时，有可能Survivor区内的部分对象失活，所以在清除Survivor区时，会出现内存碎片，当有两块Survivor区时可以避免这个问题。最终Java堆使用了两个Survivor区，一个from Survivor，一个to Survivor。第一次Eden满的时候，将存活对象放入from Survivor区，清空Eden。第二次Eden满的时候，将Eden和from Survivor区存活的对象放入to Survivor区，清空前两个区，然后将from Survivor 和 to Survivor互换。这样就解决了碎片化的问题</p><img src="/2019/08/13/Java-JVM内存管理/2.jpeg" title="This is an image"><p>老年代-整理标记法：<br>   由于老年代存放的是存活比较久的对象，所以老年代如果也采用复制法的话，会造成很大的内存开销，因为老年代中的对象基本都会存活。<br>   老年代的整理标记法首先将需要存活对象进行标记，然后让存活的对象想着一端移动按照内存地址依次排序，然后将末端内存地址回收。  </p><img src="/2019/08/13/Java-JVM内存管理/3.jpeg" title="This is an image"><p>方法区内存回收：<br> 方法区某些时候也叫“永久代”，因为该区存放的是类的信息以及一些常量信息。所以该区的内存难以回收。<br> 虽然方法区的垃圾回收效率低，但有些废弃常量和无用的类还是可以进行回收的。对于无用的类（该类所有实例都被回收，加载该类的ClassLoader也被回收，该类对象在任何地方都未引用）满足以上条件才有可能被回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc内存分配机制</title>
      <link href="/2019/08/09/malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/09/malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>malloc函数可用于动态分配内存，因为有时因为栈的空间较小，而程序所要求的内存空间较大，从而导致内存溢出，所以需要使用malloc函数在堆中申请内存。下面就来详细解释malloc函数是怎么样来分配内存的，并且我们要注意哪些问题。</p><a id="more"></a><p>一、堆在计算机中的存在形式<br>1.堆内存在内存中不是连续的，堆空间是由若干个小空间组合而成，在这里我们将每个小空间称为Heap。<br>2.每个Heap都由Header和可分配内存空间组成，Header是一种数据结构，包含这个Heap的一些信息，比如起始地址，空间大小，是否已经被分配，以及指向下一个Heap的指针等等。<br>3.这些Heap组成一个链表结构，用于保持Heap之间的联系。<br>4.一般都是使用指针的形式来访问Heap，不像栈空间可以使用变量名和指针两种形式访问。<br>二、malloc分配机制<br>当使用malloc分配内存时，计算机会依序从内存低地址到高地址开始搜索，直到搜索到一个Heap的可用内存空间大于或等于所需空间时，则将该Heap内存空间分为两部分，一部分用于分配，将该空间的起始地址返回给指针。另一部分将Header中的值修改重新加入Heap链表。为了便于free（）内存空间，经过malloc分配的堆空间也会有个Header来存储必要的信息。如果所有的Heap链中都没有满足的空间，则会返回NULL给指针。<br>这就意味着当有足够的空间可分配时，指针会被赋值地址，否则为NULL。<br>所以当我们使用malloc动态分配内存的时候我们要采用这种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *p = NULL;</span><br><span class="line">p = (char *)malloc(sizeof(char));</span><br><span class="line">if(p)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配成功后，得到的堆内存首地址一定要保存，否则会无法释放堆内存而造成内存泄露。而且不能使用未初始化指针所指向的内存空间。<br>三、指针操作堆空间<br>每当释放堆空间后（free）都应该将指针赋值为NULL。并且使用该指针指向的起始地址会有潜在危险（野指针）。<br>使用指针前判断其值是否为NULL<br>若malloc分配成功，则malloc前的强制类型转换规定链申请的堆空间要存的数据类型<br>四、free内存<br>free（）只是将指针指向的内存空间回收，其指针的值依然存在，所以需要手动置空。当释放未指向任何内存块的指针也会造成内存泄漏，所以在释放时应该先判断指针是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(p)&#123;</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br>malloc分配的堆内存结构为Header+内存空间，所以实际空间为sizeof（Header）+内存空间</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java文件处理</title>
      <link href="/2019/08/08/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2019/08/08/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java文件系统，包括目录，文件的创建，删除。读文件，写文件，java是采用数据流的形式来对文件进行读写</p><a id="more"></a><p>import java.io.*;<br>//文本文件<br>Java创建目录：<br>    File d = new File(“../../temp”);//路径../是返回上层，如果直接采用/temp则是在当前工程目录下创建<br>    if(!d.exists()) {<br>        d.mkdirs();//多级目录<br>        //d.mkdirs();单级目录<br>    }</p><p>Java创建文件：<br>    File f = new File(“../../temp/a.txt⁩”);<br>    //异常处理 try-catch<br>    if(!f.exists()) {<br>        try {<br>            f.createNewFile();//创建该文件（a.txt）<br>        }<br>        catch(Exception e) {<br>            e.printStackTrace();<br>        }</p><p>// 输出文件的相关属性<br>        System.out.println(“Is f file?” + f.isFile());<br>        System.out.println(“Name:” + f.getName());<br>        System.out.println(“Prarent:” + f.getParent());<br>        System.out.println(“Path:” + f.getPath());<br>        System.out.println(“Size:” + f.length() + “bytes”);<br>        System.out.println(“Last modified time:” + f.lastModified());</p><p>//目录，文件的删除<br>    f.delete();<br>    d.delete();</p><p>//写数据到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">OutputStreamWriter osw = null;</span><br><span class="line">BufferedWriter bw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    //节点类，负责写字节到文件</span><br><span class="line">    fos = new FileOutputStream(&quot;../../temp/a.txt&quot;);</span><br><span class="line">    //转化类，负责字符转化为字节</span><br><span class="line">    osw = new OutputStreamWriter(fos , &quot;UTF-8&quot;);</span><br><span class="line">    //装饰类，负责写字符到缓冲区</span><br><span class="line">    bw = new BufferedWriter(osw);</span><br><span class="line">    </span><br><span class="line">    bw.write(&quot;我们是&quot;);</span><br><span class="line">    //换行</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(&quot;Ecumers.^^&quot;);</span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //关闭自高层的类，底下流都会关闭</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//JDK7之后的try-resource语句，try语句结束后会自动关闭bw，更高效简洁</span><br><span class="line">try(BufferedWriter bw = </span><br><span class="line">new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;../../temp/b.txt&quot;))))&#123;</span><br><span class="line">bw.write(&quot;I am&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;ironman！&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    //读文件是只能逐行读取</span><br><span class="line">    public static void readFile() &#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    InputStreamReader isr = null;</span><br><span class="line">    BufferedReader br = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        fis = new FileInputStream(&quot;../../temp/a.txt&quot;);</span><br><span class="line">        isr = new InputStreamReader(fis , &quot;UTF-8&quot;);</span><br><span class="line">        br = new BufferedReader(isr);</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null)</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //关闭自高层的类，底下流都会关闭</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;catch(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void readFile2() &#123;</span><br><span class="line">    try(BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;../../temp/b.txt&quot;))))&#123;</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//二进制文件读写</span><br><span class="line">//JDK7之前的写法</span><br><span class="line">    public static void binWriteFile() &#123;</span><br><span class="line">    FileOutputStream fos = null;</span><br><span class="line">    DataOutputStream dos = null;</span><br><span class="line">    BufferedOutputStream bos = null;</span><br><span class="line">    try &#123;</span><br><span class="line">    fos = new FileOutputStream (&quot;../../temp/b.dat&quot;);</span><br><span class="line">    bos = new BufferedOutputStream(fos);</span><br><span class="line">    dos = new DataOutputStream(bos);</span><br><span class="line">    </span><br><span class="line">    dos.writeUTF(&quot;a&quot;);</span><br><span class="line">    dos.writeInt(20);</span><br><span class="line">    dos.writeUTF(&quot;b&quot;);</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> //JDK7之后的try-source写法   </span><br><span class="line">    public static void binReadFile() &#123;</span><br><span class="line">    try(DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream(&quot;../../temp/b.dat&quot;))))&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(dis.readUTF());</span><br><span class="line">    System.out.println(dis.readInt());</span><br><span class="line">    System.out.println(dis.readUTF());</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zip文件读写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//单文件压缩</span><br><span class="line">public static void oneFileZip() throws Exception&#123;</span><br><span class="line">//b.txt已经存在在temp目录下</span><br><span class="line">File file = new File(&quot;../../temp/a.txt&quot;);</span><br><span class="line">//a.zip不存在，只是定义压缩文件的名称</span><br><span class="line">File zipFile = new File(&quot;../../temp/a.zip&quot;);</span><br><span class="line">//定义文件的输入流</span><br><span class="line">InputStream input = new FileInputStream(file);</span><br><span class="line">//声明压缩流对象</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">//设置zipEntry对象,文件名称设置为原来的文件名，也可自行修改为其他例如（dd.txt）</span><br><span class="line">zos.putNextEntry(new ZipEntry(file.getName()));</span><br><span class="line">    //该程序采用每次读取一个字节，temp来记录一个字节的值</span><br><span class="line">int temp = 0;</span><br><span class="line">//当读到文件末尾时会返回-1</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line"> System.out.println(temp);</span><br><span class="line"> //将从a.txt中读出的数据写入zipEntry中</span><br><span class="line">     zos.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">zos.close();</span><br><span class="line">System.out.println(&quot;zip is finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//多文件压缩</span><br><span class="line">public static void multipleFileZip() throws Exception&#123;</span><br><span class="line">//打开一个准备压缩的目录</span><br><span class="line">File file = new File(&quot;../../temp&quot;);</span><br><span class="line">//压缩后的zip包名</span><br><span class="line">File zipFile = new File(&quot;../../test.zip&quot;);</span><br><span class="line">//定义文件输入数据流</span><br><span class="line">InputStream input = null;</span><br><span class="line">//定义压缩流</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">//开始压缩</span><br><span class="line">int temp = 0;</span><br><span class="line">if(file.isDirectory()) &#123;</span><br><span class="line">//将该目录下所有的文件都存放到Lists数组</span><br><span class="line">File lists[] = file.listFiles();</span><br><span class="line">for(int i=0;i &lt; lists.length ;++i) &#123;</span><br><span class="line">//让input指向lists中的每个文件</span><br><span class="line">input = new FileInputStream(lists[i]);</span><br><span class="line">//设置zipEntry列表，按级取名</span><br><span class="line">zos.putNextEntry(new ZipEntry(file.getName() + File.separator + lists[i].getName()));</span><br><span class="line">System.out.println(&quot;正在压缩&quot;+lists[i].getName());</span><br><span class="line">//每次按一个字节压缩</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line">zos.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">zos.close();</span><br><span class="line">System.out.println(&quot;zip is finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//单文件解压</span><br><span class="line">    public static void oneFileUnzip() throws Exception&#123;</span><br><span class="line">File zipFile = new File(&quot;../../temp/a.zip&quot;);</span><br><span class="line">File outfile = new File(&quot;../../temp/dd.txt&quot;);</span><br><span class="line">ZipInputStream input = new ZipInputStream(new FileInputStream(zipFile));</span><br><span class="line">ZipEntry entry = input.getNextEntry();</span><br><span class="line">System.out.println(&quot;压缩实体名称&quot; + entry.getName());</span><br><span class="line"></span><br><span class="line">OutputStream out = new FileOutputStream(outfile);</span><br><span class="line">int temp = 0;</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line">out.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">out.close();</span><br><span class="line">System.out.println(&quot;unzip is finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//多文件解压</span><br><span class="line">public static void multipleFileUnzip() throws Exception&#123;</span><br><span class="line">//打开待解压的压缩包</span><br><span class="line">File file = new File(&quot;../../test.zip&quot;);</span><br><span class="line">//转化，将普通文件对象转化为压缩包实体对象</span><br><span class="line">ZipFile zipFile = new ZipFile(file);</span><br><span class="line">//将文件流转化为zip数据流</span><br><span class="line">ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file));</span><br><span class="line"></span><br><span class="line">OutputStream out = null;</span><br><span class="line">InputStream input = null;</span><br><span class="line">ZipEntry entry = null;</span><br><span class="line">//每次从压缩包中获取一个entry</span><br><span class="line">while((entry = zipInput.getNextEntry()) != null) &#123;</span><br><span class="line">System.out.println(&quot;解压缩&quot;+entry.getName());</span><br><span class="line">//输出文件的路径</span><br><span class="line">File outFile = new File(&quot;../../&quot;+entry.getName());</span><br><span class="line">//如果输出文件夹的上级路径不存在，则创建</span><br><span class="line">if(!outFile.getParentFile().exists()) &#123;</span><br><span class="line">outFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">//如果输出文件夹不存在，创建</span><br><span class="line">if(!outFile.exists()) &#123;</span><br><span class="line">//如果entry是一个目录，则压缩后依然是目录，则创建目录，如果是文件则创建文件</span><br><span class="line">if(entry.isDirectory()) &#123;</span><br><span class="line">outFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">outFile.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果entry是一个文件，则将数据解压到文件</span><br><span class="line">if(!entry.isDirectory()) &#123;</span><br><span class="line">//得到entry实体的输入流</span><br><span class="line">input = zipFile.getInputStream(entry);</span><br><span class="line">//得到输出文件的输出流</span><br><span class="line">out = new FileOutputStream(outFile);</span><br><span class="line">int temp = 0;</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line">out.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用的数据结构</title>
      <link href="/2019/08/01/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/08/01/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>关于Java的List（列表），Set（集合），++a和a++的具体区别</p><a id="more"></a><p>List：<br>ArrayList（可变数组）：基于数组的数据结构，遍历最好采用随机索引和foreach去遍历。尽量少用add，会造成大部分元素的移动，时间复杂度为O(n)，少添加和删除。<br>LinkedList：基于双向链表的数据结构，遍历最好采用迭代器和foreach去遍历，可以用add，链表的添加和删除都是O(1)<br>Vector：类似于ArraList，多一个遍历方法Emuration（类似于iterator）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//三种遍历方式</span><br><span class="line">public static void traverseByIterator(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========迭代器遍历=========&quot;);</span><br><span class="line">    Iterator&lt;Integer&gt;iter1 = a1.iterator();</span><br><span class="line">    while(iter1.hasNext()) &#123;</span><br><span class="line">    iter1.next();</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void traverseByIndex(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========随机索引遍历=========&quot;);</span><br><span class="line">    for(int i=0;i &lt; a1.size();++i) &#123;</span><br><span class="line">    a1.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void traverseByFor(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========For循环遍历=========&quot;);</span><br><span class="line">    for(Integer item : a1) &#123;</span><br><span class="line">    ;</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Set：<br>HashSet和LinkedHashSet的判断是根据hashCode和equals来进行判别两个是否对象是否相等，而TreeSet必须通过实现comparable接口里面的compareTo方法，否则会报语法错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class cat&#123;</span><br><span class="line">private int size;</span><br><span class="line">cat(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">    HashSet&lt;cat&gt;hs = new HashSet&lt;cat&gt;();</span><br><span class="line">    hs.add(new cat(1));</span><br><span class="line">    hs.add(new cat(1));</span><br><span class="line">    System.out.println(hs.size());</span><br><span class="line">//输出2   </span><br><span class="line"></span><br><span class="line">class dog&#123;</span><br><span class="line">private int size;</span><br><span class="line">dog(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">System.out.println(&quot;Dog hashCode&quot;);</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">/*该方法的参数必须是Object类型，如果为dog类型虽然不会报错，但输出结果会为2，equals方法不会被调用*/</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">System.out.println(&quot;Dog equals&quot;);</span><br><span class="line">if(0 == size - ((dog)obj).getSize())</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">System.out.println(&quot;Dog toString&quot;);</span><br><span class="line">return size + &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">        LinkedHashSet&lt;dog&gt;hs2 = new LinkedHashSet&lt;dog&gt;();</span><br><span class="line">hs2.add(new dog(1));</span><br><span class="line">hs2.add(new dog(1));</span><br><span class="line">System.out.println(hs2.size());</span><br><span class="line">//输出1</span><br><span class="line"></span><br><span class="line">//tiger类实现Comparable接口中的compareTo()方法</span><br><span class="line">class tiger implements Comparable&#123;</span><br><span class="line">private int size;</span><br><span class="line">tiger(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int compareTo(Object obj) &#123;</span><br><span class="line">   return size - ((tiger)obj).getSize();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试，最后输出1</span><br><span class="line">        TreeSet&lt;tiger&gt; ts = new TreeSet&lt;tiger&gt;();</span><br><span class="line">ts.add(new tiger(1));</span><br><span class="line">ts.add(new tiger(1));</span><br><span class="line">System.out.println(ts.size());</span><br><span class="line"></span><br><span class="line">//如果写TreeSet&lt;dog&gt; ts = new TreeSet&lt;dog&gt;();会报语法错误</span><br></pre></td></tr></table></figure><p>a = 1：首先将常量1压入栈顶，后面将栈顶1弹出赋值给a，栈为空<br>a = a++：结果a = 1，因为a = a++是先将a的值1压入栈顶，再执行a+1操作，这时a的值为2，最后将栈顶的1弹出赋值给a，所以a=1；<br>a = ++a：结果a=2，因为a = ++a是先将a执行a+1操作，此时a等于，再将a的数值2压入栈顶，最后将2弹出并赋值给a，所以a=2</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="/2019/07/26/Dijkstra/"/>
      <url>/2019/07/26/Dijkstra/</url>
      
        <content type="html"><![CDATA[<p>单源最短路径：一个顶点到图中其它顶点的最短通路长度</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//顶点数为n，边数为m，该算法的时间复杂度为O(n^2)</span><br><span class="line">/*采用n*n矩阵存储数据,此代码是求顶点1到其他顶点的最短路，后面那个优化的是可以从任意顶点开始 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1e9</span><br><span class="line"></span><br><span class="line">static int Count = 2; //计数器判断算法结束</span><br><span class="line">int dis[10][10]; //矩阵存储数据</span><br><span class="line">bool flag[10] = &#123;0&#125;; //判断顶点是否已经访问过</span><br><span class="line">int range[10] = &#123;0&#125;;  // 存储源点到其他顶点的距离</span><br><span class="line">int res_record[10] = &#123;0,1,1,1,1,1,1,1,1,1&#125;; //记录从源点开始依次找到的点</span><br><span class="line"></span><br><span class="line">int MIN(int n)&#123;  //寻找最小距离的点</span><br><span class="line">    int t ;</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        if(flag[i]) continue;//所找到的点为已经找到的</span><br><span class="line">        else&#123;</span><br><span class="line">            t = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        if(range[t] &gt; range[i] &amp;&amp; !flag[i])&#123;</span><br><span class="line">            t = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">//点矩阵，距离矩阵的初始化</span><br><span class="line">void Init(int n)&#123;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">      dis[i][i] = MAX;</span><br><span class="line">   &#125; </span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       for(int j=1;j &lt; i ;++j)&#123;</span><br><span class="line">           cin &gt;&gt; dis[i][j];</span><br><span class="line">           dis[j][i] = dis[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">      range[i] = dis[1][i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> //每次找到一个点后对距离矩阵进行调整</span><br><span class="line">void Adjust(int i,int n)&#123;</span><br><span class="line">    for(int j=2;j &lt;= n;++j)&#123;</span><br><span class="line">        //判断依据是min(range[j],range[i]+dis[i][j])</span><br><span class="line">        if((!flag[j]) &amp;&amp; (range[j] &gt; range[i] + dis[i][j]))&#123;</span><br><span class="line">            //记录每个点的前驱</span><br><span class="line">           res_record[j] = i;</span><br><span class="line">           range[j] = range[i]+ dis[i][j];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int n)&#123;</span><br><span class="line">    while(Count &lt;= n)&#123;</span><br><span class="line">        //找到最小距离所对应的点</span><br><span class="line">        int t = MIN(n);</span><br><span class="line">        //判断该点是否以及被访问</span><br><span class="line">        if(!flag[t])&#123;</span><br><span class="line">           flag[t] = true;</span><br><span class="line">           Count++;</span><br><span class="line">           Adjust(t,n);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环查找最小距离所途经的点</span><br><span class="line">void find(int k)&#123;</span><br><span class="line">    int p = 0,t = 0;</span><br><span class="line">     while(k != 1)&#123;</span><br><span class="line">         range[t++] = k;</span><br><span class="line">         p += dis[k][res_record[k]];</span><br><span class="line">         k = res_record[k];</span><br><span class="line">     &#125;</span><br><span class="line">     range[t++] = 1;</span><br><span class="line">     for(int i=t-1;i &gt;= 1;--i)</span><br><span class="line">       cout &lt;&lt; range[i] &lt;&lt; &quot;--&gt;&quot;;</span><br><span class="line">       cout &lt;&lt; range[0] &lt;&lt; &quot;   &quot;&lt;&lt; &quot;距离:&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Init(n);</span><br><span class="line">    dijkstra(n);</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        find(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法还可以进行改进，主要是在求最小range最小距离时可以使用最小堆（优先队列），可使复杂度降为O(nlog(n)) 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//采用n*n矩阵存储数据 </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1e9</span><br><span class="line">//小根堆</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    bool operator &lt; (const node &amp;a)const&#123;</span><br><span class="line">        return x &gt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static int Count = 2;</span><br><span class="line">int dis[10][10]; //矩阵存储数据</span><br><span class="line">int res_record[10] = &#123;0,1,1,1,1,1,1,1,1,1&#125;; //记录从源点开始依次找到的点</span><br><span class="line">priority_queue&lt;node&gt;Q;//优先队列</span><br><span class="line">vector&lt;node&gt;v;</span><br><span class="line"></span><br><span class="line">//点矩阵，距离矩阵的初始化</span><br><span class="line">void Init(int n,int m)&#123;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">      dis[i][i] = MAX;</span><br><span class="line">   &#125; </span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       for(int j=1;j &lt; i ;++j)&#123;</span><br><span class="line">           cin &gt;&gt; dis[i][j];</span><br><span class="line">           dis[j][i] = dis[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       node a ;</span><br><span class="line">       a.x = dis[m][i];</span><br><span class="line">       a.y = i;</span><br><span class="line">       Q.push(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dijkstra(int n,int m)&#123;</span><br><span class="line">    while(Count &lt;= n)&#123;</span><br><span class="line">        //找到最小距离所对应的点</span><br><span class="line">        node a = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Count++;</span><br><span class="line">        while(!Q.empty())&#123;</span><br><span class="line">            node b = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            if(b.x &gt; a.x + dis[a.y][b.y])&#123;</span><br><span class="line">                b.x = a.x + dis[a.y][b.y];</span><br><span class="line">                res_record[b.y] = a.y;</span><br><span class="line">            &#125;</span><br><span class="line">            v.push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i &lt; v.size();++i)&#123;</span><br><span class="line">            Q.push(v[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        v.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环查找最小距离所途经的点</span><br><span class="line">void find(int k,int m)&#123;</span><br><span class="line">    int p = 0,t = 1;</span><br><span class="line">    int record[10] = &#123;0&#125;;</span><br><span class="line">    record[0] = k;</span><br><span class="line">     while(k != m)&#123;</span><br><span class="line">         p += dis[k][res_record[k]];</span><br><span class="line">         k = res_record[k];</span><br><span class="line">         record[t++] = k;</span><br><span class="line">     &#125;</span><br><span class="line">     for(int i=t-1;i &gt;= 1;--i)&#123;</span><br><span class="line">         cout &lt;&lt; record[i] &lt;&lt; &quot;--&gt;&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">        cout &lt;&lt; record[0] &lt;&lt; &quot; 距离:  &quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //n个顶点，从第m个点出发</span><br><span class="line">    int n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">        res_record[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    Init(n,m); </span><br><span class="line">    dijkstra(n,m);</span><br><span class="line">    for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">        if(m == i) continue;</span><br><span class="line">        find(i,m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
