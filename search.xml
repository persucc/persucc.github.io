<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>打卡第三天</title>
      <link href="/2019/10/12/%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
      <url>/2019/10/12/%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天在编写一个字符串最大回文串的过程中，遇到了一个很奇怪的问题，为什么StringBuffer的toString方法不能等同于同样内容的String，这让我很困惑，我顺手就翻看了StringBuffer的源码，然后就看到了一个我从未见过的关键词transient，下面就对以上两个知识点进行解释</p><a id="more"></a><p>一：transient<br>  在说明transient时，我首先要引入另一个我也没听过的概念序列化，在我阅读了某位大神的博客之后，我认为序列化就是将某个类的实例对象存储在内存空间中，众所周知，Java程序必须运行在JVM之上，那么Java的各种类的对象也都必须在JVM之上才能运行，如果JVM停止运行，那么类的对象都将消失，而序列化就是解决这个问题的，当jVM停止运行之后，序列化对象将依然存在，可供其他主机的JVM调用。此外，序列化对象是针对类中的成员变量的，如果是类的静态变量，方法都不会被序列化。最后说明一点，要想实现类的序列化，必须实现一个叫Serializable的接口，，这样才能序列化 ，在Java中有些类本来就实现了Serializable接口，比如String，或数组，或Enum，或Serializable，那么就可以对该对象进行序列化。然后回到我们的主题，因为序列化是默认将所有的成员变量都序列化，而transient就是阻止这种情况，所以当你在成员变量之前加上这个关键字时，这个成员变量将会不被序列化而存储。<br>  下面看这个例子，应该能更深刻的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import exe_1.LeetCode.Gender;</span><br><span class="line"></span><br><span class="line">//import exe_1.Persons.Gender;</span><br><span class="line"></span><br><span class="line">public class LeetCode &#123;</span><br><span class="line">public enum Gender&#123;</span><br><span class="line">male,female</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //生成文件person.out</span><br><span class="line">File file = new File(&quot;person.out&quot;);</span><br><span class="line">        //ObjectOutputStream是能将一个对象转化成二进制流，前提是该方法需要传入OutputStream的流来转化</span><br><span class="line">ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">        //new一个Persons类的对象，放入文件中</span><br><span class="line">oout.writeObject(new Persons(20,&quot;ym&quot;,Gender.male));</span><br><span class="line">oout.close();</span><br><span class="line">//从内存中指定位置读取该对象的二进制流并转化为对象</span><br><span class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object object = oin.readObject();</span><br><span class="line">oin.close();</span><br><span class="line"></span><br><span class="line">Persons newPerson =  (Persons)object;</span><br><span class="line">        //打印出信息</span><br><span class="line">System.out.println(newPerson.show());</span><br><span class="line">//return newPerson.show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Persons implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">transient private Integer age = null;</span><br><span class="line">private String name;</span><br><span class="line">private Gender gender;</span><br><span class="line">public Persons(int age , String name ,Gender gender) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name ;</span><br><span class="line">this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String show() &#123;</span><br><span class="line">return age +&quot; &quot; + name + &quot; &quot; + gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">null ym male</span><br></pre></td></tr></table></figure><p>从以上例子可以看出，如果一个类的成员变量声明为transient，则该成员变量不会被序列化。<br>默认序列化机制：<br>    如果仅仅只是让某个类实现Serializable接口，而没有其它任何处理的话，则就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。</p><p>二：StringBuffer.toString()与String的区别<br>下面请看这段代码：<br>String a = “aa”;<br>StringBuffer strb = new StringBuffer(a);<br>System.out.println(a == strb.toString());<br>这段代码将会输出null</p><p>这是我在写这个题的时候，出现的问题，以上是我简化后的一个简单实验</p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><p>一开始，我是真的没弄懂为啥以上等式不会成立，后面到了晚上突然醒悟过来，原因是这样的，String的”==“其实不是判断两个字符串的内容是否相等，而是判断两个字符串所引用的堆空间的地址是否相等，下面就再仔细解释一下，String a = “aa”;这代码执行是这样的，现在字符常量池中查找是否由aa这个字符串存在，如果有则直接将其地址复制于引用a，否则就在一个堆1空间（姑且这样说）生成aa并且返回地址给a。如果是String a = new String(“aa”)；这样的话，将会在堆2空间生成并返回地址个栈空间的引用a。下面就来解释为什么System.out.println(a == strb.toString());显而易见a是堆一空间的地址，而strb.toString()是堆二空间的地址（这里不细说，可自行百度，new出来的对象一定是堆2空间）。<br>如果使用下面这条语句<br>System.out.println(a.equalsIgnoreCase(strb.toString()));输出就为true，因为equals方法是能实现stirng内容的比较。<br>下面贴上我之所以wrong answer的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        StringBuffer strb = new StringBuffer(s);</span><br><span class="line">        String str = null;</span><br><span class="line">        int tmp = s.length() ;</span><br><span class="line">        while(tmp &gt;= 0)&#123;</span><br><span class="line">            for(int i=0; i &lt; s.length() - tmp + 1;++i)&#123;</span><br><span class="line">                if(tmp % 2 == 1)&#123;</span><br><span class="line">                   System.out.println(strb.substring(i , i+tmp/2+1) == new StringBuffer(strb.substring(i+tmp/2 , i+tmp/2*2+1)).reverse().toString());</span><br><span class="line">                     if(strb.substring(i , i+tmp/2+1) == new StringBuffer(strb.substring(i+tmp/2 , i+tmp/2*2+1)).reverse().toString())&#123;  </span><br><span class="line">                        str = strb.substring(i,i+tmp/2*2+1);</span><br><span class="line">                         break;</span><br><span class="line">                     &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if(strb.substring(i , i+tmp/2).toString() == new StringBuffer(strb.substring(i+tmp/2 , i+tmp/2*2)).reverse().toString())&#123;</span><br><span class="line">                       str =  strb.substring(i,tmp/2*2+i);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            --tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只需要将if中的==改为equals方法就能ac了。<br>由以上我想到一个更容易错的例子：<br>String a = “aa”;<br>String b = new String(“aa”);<br>System.out.println（a==b）这里也是输出false的，理由同上！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打卡第2天</title>
      <link href="/2019/10/09/%E6%89%93%E5%8D%A1%E7%AC%AC2%E5%A4%A9/"/>
      <url>/2019/10/09/%E6%89%93%E5%8D%A1%E7%AC%AC2%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天主要是想写一个贪吃蛇游戏的思路和想法，下次再补代码。因为最近时间真的有点紧。</p><a id="more"></a><p>一.开发环境<br>Java + Eclipse<br>一.设计游戏界面<br>首先设计一个900*700的窗口,如下图所示：</p><img src="/2019/10/09/打卡第2天/1.png" title="This is an image"><p>25x25是一个单元格的大小，10是窗口与标题的间距，11是标题与游戏区的间隔，然后四周与窗口都是25的间隔，因为贪吃蛇图片素材刚好是25x25的，经过ps可以将标题的大小改变成所要的，所以才这样设计。以下就是图片：<br>game title：<img src="/2019/10/09/打卡第2天/tiltle.png" title="This is an image"><br>snake body：<img src="/2019/10/09/打卡第2天/body.png" title="This is an image"><br>snake food：<img src="/2019/10/09/打卡第2天/food.png" title="This is an image"><br>snake head：<img src="/2019/10/09/打卡第2天/right.png" title="This is an image"><br>二.游戏区设置<br>游戏区设置需要使用到JFrame来创建窗口，然后使用Jpanel画布来操作画笔对象Graphics来做图像。<br>三.蛇的数据结构<br>这里为了方便，我就用两个数组来分别存储x方向和y方向的位置，然后由这两个数组可以将图片显示到对应的地方，此外设置一个length来记录蛇的长度<br>四.蛇的方向控制<br>我这里是使用4个不同的蛇头图片来展示蛇移动4个不同的方向，例如，当蛇的方向由右变为下时，需要做的是将y的值递减25，x的值保持不变。同时当方向改变的一瞬间，需要将蛇头的图片改变，然后蛇的身体部分的后面一节按照改为前一节就可以了<br>五.实现暂停功能<br>使用Java的接口KeyListener来监听键盘，我这里使用空格键来实现暂停功能，所以只需要使用监听函数就可以实现了，同理蛇的左右的移动通过获取键盘的press来实现。<br>六.蛇吃食物<br>食物通过随机函数，随机生成在游戏区，蛇吃食物需要判断的是，蛇的头部是否与食物的x，y的坐标值相同，如果相同，则length+1<br>七.蛇的移动问题<br>蛇的移动通过Timer定时器来完成，每隔一定的时间就将数组中的值更新，这样就可以实现蛇的移动，实现速度。<br>八. 游戏结束<br>蛇如果头部节点与body节点由重复则游戏over，并且如果蛇碰壁来，也算是游戏结束，这些主要是通过if判断即可实现</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打卡第一天</title>
      <link href="/2019/10/08/%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2019/10/08/%E6%89%93%E5%8D%A1%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天打卡第一天，有点不知道写啥，所以就随便写了点想写的。归并排序是一直想写的，里面涉及到递归的一些算法，并且曾经在oj上遇到过一个题，用C++ STL中的sort并不能通过，而归并排序则accepted，因为当时比较分奴，所以什么也没管就过去了。现在重新写下底层的算法来提升一下。并且顺便就写了一下经典的插入排序，发现我竟然调试了半个小时才写出来，有点心酸。最后附上一个关于Java邮件操作的代码,邮件操作也是等了好几天才去学习的，发现其实还挺有意思。</p><a id="more"></a><p>插入排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class InsertSortTest&#123;</span><br><span class="line">private static ArrayList&lt;Integer&gt;al;</span><br><span class="line">private static int len;</span><br><span class="line"></span><br><span class="line">public InsertSortTest(ArrayList&lt;Integer&gt;al) &#123;</span><br><span class="line">len = al.size();</span><br><span class="line">this.al = new ArrayList&lt;Integer&gt;(len);</span><br><span class="line">this.al = al;</span><br><span class="line">&#125;</span><br><span class="line">//从小到大排序，时间复杂度为O(n^2)</span><br><span class="line">public void sort() &#123;</span><br><span class="line">int i,j;</span><br><span class="line">for(i = 1;i &lt; len ;++i) &#123;</span><br><span class="line">int value = al.get(i);</span><br><span class="line">//把当前的值与已经排序好的队列进行比较，若前面序号位置的数大于该数则向后赋值，直至找到该数的位置</span><br><span class="line">for(j = i-1 ;j &gt;= 0 &amp;&amp; al.get(j) &gt; value; --j) &#123;</span><br><span class="line">al.set(j+1, al.get(j)) ;</span><br><span class="line">&#125;</span><br><span class="line">//对最后一个位置赋值</span><br><span class="line">al.set(j+1, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">for(Integer i : al) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class MergeSortTest&#123;</span><br><span class="line">private static ArrayList&lt;Integer&gt;al;</span><br><span class="line">private int len;</span><br><span class="line">private ArrayList&lt;Integer&gt;res;</span><br><span class="line"></span><br><span class="line">public MergeSortTest(ArrayList&lt;Integer&gt;al) &#123;</span><br><span class="line">this.len = al.size();</span><br><span class="line">this.al = new ArrayList&lt;&gt;();</span><br><span class="line">this.al = al;</span><br><span class="line">this.res  = new ArrayList&lt;&gt;(this.len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*归并排序采用先分后合的思路，不管序列如何时间复杂度一定是O(nlogn)，</span><br><span class="line"> * 可以把归并排序看作一个树，树的高度是n个元素二等分直至将每个节点都转化成叶子结点</span><br><span class="line"> *归并排序的分用递归程序写比较简单易行</span><br><span class="line"> * */</span><br><span class="line">public void divideArrayList(int start , int end ,ArrayList&lt;Integer&gt;al) &#123;</span><br><span class="line">if(start &gt;= end) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int middle = (start+end)/2;</span><br><span class="line">//递归向左分到集合中的元素只有一个</span><br><span class="line">divideArrayList(start,middle,al);</span><br><span class="line">//递归向右</span><br><span class="line">divideArrayList(middle+1,end,al);</span><br><span class="line">mergeArrayList(start,middle,end,al);</span><br><span class="line">&#125;</span><br><span class="line">//将各个叶子节点，根结点合并</span><br><span class="line">public void mergeArrayList(int start ,int middle ,int end ,ArrayList&lt;Integer&gt;al) &#123;</span><br><span class="line">int index = 0;</span><br><span class="line">int i = start;</span><br><span class="line">int j = middle+1;</span><br><span class="line">//中间数组来存储每次合并的结果，否则会破坏排好序的结果</span><br><span class="line">int temp[] = new int[end-start+1];</span><br><span class="line">while(i &lt;= middle &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">if(al.get(i) &lt; al.get(j)) &#123;</span><br><span class="line">temp[index++] = al.get(i++);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">temp[index++] = al.get(j++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i &lt;= middle) &#123;</span><br><span class="line">temp[index++] = al.get(i++);</span><br><span class="line">&#125;</span><br><span class="line">while(j &lt;= end) &#123;</span><br><span class="line">temp[index++] = al.get(j++);</span><br><span class="line">&#125;</span><br><span class="line">for(int a = 0,b = start ;a &lt; temp.length;++a) &#123;</span><br><span class="line">al.set(b++,temp[a]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">for(Integer i : al) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一.邮件知识简介<br>说到邮件一定离不开两个协议，一个是SMTP（收邮件），一个是POP3（发邮件）。所以说如果要实现邮件的收发，必须要有一个SMTP服务器，一个Pop3服务器，还有一个存储设备来实现缓冲以及转发。<br>二.Java中的邮件<br>Java中的邮件主要是通过Java Mail组件中的API函数来实现与SMTP，Pop3服务器进行通信。因此Java的作用主要是联系各种服务器来收发邮件，具体的细节操作Java目前还不能完成。<br>三.具体操作<br>本人的开发环境是Eclipse，并且Java的邮件操作需要引用Javax.mail包，所以为了方便我这里使用Maven项目来做。<br>需要将以下javax.mail的依赖需要放到porm.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.mail&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>四 .关键类<br>Session用于邮件会话<br>Store邮件存储空间<br>Folder邮件文件夹<br>Message电子邮件<br>Address邮件地址<br>Transport：发送协议类<br>如果要该代码能实现，必须先去QQ邮箱客户端，开通imap协议！！！<br>该代码主要实现连接腾讯公司的imap服务器，来实现获取自己或别人的收件箱，以得到信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package JavaMail;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import javax.mail.*;</span><br><span class="line">import javax.mail.internet.MimeUtility;</span><br><span class="line">import com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line">public class MailRecive &#123;</span><br><span class="line">//Java用于连接https网站的证书，如果没有就不能连接上qq邮箱的网站</span><br><span class="line">final String SSL_FACTORY = &quot;javax.net.ssl.SSLSocketFactory&quot;;</span><br><span class="line">    private Session session;</span><br><span class="line">    private Store store;</span><br><span class="line">    //imap协议用的端口</span><br><span class="line">    private String port = &quot;993&quot;;</span><br><span class="line">    //设置QQ邮箱的登陆帐号</span><br><span class="line">    private String username = &quot;xxxxxx&quot;;</span><br><span class="line">    private String protocol = &quot;imap&quot;;</span><br><span class="line">    //QQ邮箱的登陆密码，这里是用密钥，需要你自己去邮箱客户端获取</span><br><span class="line">    private String password = &quot;xxxxx&quot;;</span><br><span class="line">    //QQ邮箱服务器地址</span><br><span class="line">    private String imapServer = &quot;imap.qq.com&quot;;</span><br><span class="line">    </span><br><span class="line">    public void init()throws Exception&#123;</span><br><span class="line">    //Properties是一个配置文件类，基于Hashtable，是一种k-v对</span><br><span class="line">    Properties props = new Properties();</span><br><span class="line">    props.setProperty(&quot;mail.imap.socketFactory.class&quot;, SSL_FACTORY);</span><br><span class="line">        props.setProperty(&quot;mail.imap.socketFactory.fallback&quot;, &quot;false&quot;);</span><br><span class="line">        props.setProperty(&quot;mail.transport.protocol&quot;, protocol); </span><br><span class="line">        props.setProperty(&quot;mail.imap.port&quot;, port);</span><br><span class="line">        props.setProperty(&quot;mail.imap.socketFactory.port&quot;, port);</span><br><span class="line">        //getInstance会去寻找properties配置文件，并使用</span><br><span class="line">    session = Session.getInstance(props ,null);</span><br><span class="line">    //setDebug将会打印出调试信息，如果设置为false将不会打印，默认是打印出来</span><br><span class="line">    session.setDebug(false);</span><br><span class="line">    //通过用户指定协议来生成对应的存储空间</span><br><span class="line">    store = session.getStore(protocol);</span><br><span class="line">    //连接</span><br><span class="line">    store.connect(imapServer , username ,password);</span><br><span class="line">    &#125;</span><br><span class="line">    public void receiveMessage() throws Exception&#123;</span><br><span class="line">    String folderName = &quot;inbox&quot;;</span><br><span class="line">    Folder folder = store.getFolder(folderName);</span><br><span class="line">    if(folder == null) &#123;</span><br><span class="line">    throw new Exception(folderName+ &quot;邮件夹不存在&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    folder.open(Folder.READ_ONLY);</span><br><span class="line">    System.out.println(&quot;总共有&quot;+folder.getMessageCount()+&quot;封邮件&quot;);</span><br><span class="line">    System.out.println(&quot;总共有&quot;+folder.getUnreadMessageCount()+&quot;封未读邮件&quot;);</span><br><span class="line">    </span><br><span class="line">    Message[] messages = folder.getMessages();</span><br><span class="line">    for(int i=1 ; i &lt; messages.length ;++i) &#123;</span><br><span class="line">    System.out.println(&quot;     第&quot;+i+&quot;封邮件     &quot;);</span><br><span class="line">    Message message = messages[i];</span><br><span class="line">    System.out.println(decodeText(message.getFrom()[0].toString()));</span><br><span class="line">    System.out.println(message.getSubject());</span><br><span class="line">    System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    folder.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void close() throws Exception&#123;</span><br><span class="line">    store.close();</span><br><span class="line">    &#125;</span><br><span class="line">    //因为邮件默认使用Ascll码值，所以需要该函数来转码才能获得中文，否则出现乱码</span><br><span class="line">    protected static String decodeText(String text) throws Exception &#123;  </span><br><span class="line">        if (text == null)  </span><br><span class="line">         return null;  </span><br><span class="line">        if (text.startsWith(&quot;=?GB&quot;) || text.startsWith(&quot;=?gb&quot;))  </span><br><span class="line">         text = MimeUtility.decodeText(text);  </span><br><span class="line">        else  </span><br><span class="line">         text = new String(text.getBytes(&quot;ISO8859_1&quot;));  </span><br><span class="line">        return text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">MailRecive client = new MailRecive();</span><br><span class="line">client.init();</span><br><span class="line">client.receiveMessage();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这份代码可实现定时向某个人发送邮件，如果想要有用的话，可实现多线程操作，每次发出不一样的邮件主题和信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package JavaMail;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.mail.*;</span><br><span class="line">import javax.mail.internet.InternetAddress;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import javax.mail.internet.MimeMessage.RecipientType;</span><br><span class="line"></span><br><span class="line">import com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line">public class MailSend &#123;</span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">/*可实现多线程操作</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">*/</span><br><span class="line">int i =  0;</span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.setProperty(&quot;mail.transport.protocol&quot;, &quot;SMTP&quot;);</span><br><span class="line">        props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);// 指定验证为true</span><br><span class="line">        //设置发送邮件的服务器</span><br><span class="line">        props.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;);</span><br><span class="line">        MailSSLSocketFactory sf = new MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(true);</span><br><span class="line">        props.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);</span><br><span class="line">        props.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf);</span><br><span class="line">        // 创建验证器</span><br><span class="line">        Authenticator auth = new Authenticator() &#123;</span><br><span class="line">            public PasswordAuthentication getPasswordAuthentication() &#123;</span><br><span class="line">                //设置发送人的帐号和密码</span><br><span class="line">                return new PasswordAuthentication(&quot;xxxxx@qq.com&quot;, &quot;xxxxxx&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Session session = Session.getInstance(props, auth);</span><br><span class="line">        Message message = new MimeMessage(session);</span><br><span class="line"></span><br><span class="line">        //设置发送者</span><br><span class="line">        message.setFrom(new InternetAddress(&quot;xxxxx@qq.com&quot;));</span><br><span class="line"></span><br><span class="line">        //设置发送方式与接收者</span><br><span class="line">        message.setRecipient(RecipientType.TO, new InternetAddress(&quot;xxxxxxxx.com&quot;));</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line"></span><br><span class="line">        //设置邮件主题</span><br><span class="line">        message.setSubject(&quot;From GeGe&quot;);</span><br><span class="line"></span><br><span class="line">        //设置邮件内容</span><br><span class="line">        message.setContent(&quot;to DiDi！&quot;, &quot;text/html;charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">        // 3.创建 Transport用于将邮件发送</span><br><span class="line">        Transport.send(message);</span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">        ++i;</span><br><span class="line">        System.out.println(&quot;第&quot;+i+&quot;封&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类详解</title>
      <link href="/2019/08/22/String%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/22/String%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>String类是Java中一个最基本的类，因此必须深入理解String类的工作原理以及正确的使用方法</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三个字符串类的比较</title>
      <link href="/2019/08/19/%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2019/08/19/%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>Java有三个字符串类，在编程过程中到底该使用哪个呢，下面来仔细探讨</p><a id="more"></a><p>String类型:<br>String类的部分源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">   private final char value[];//final类型char数组</span><br><span class="line">//省略其他代码……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由String类源码可以看出，String类是通过字符数组来存储字符串的，但是其value是用final修饰，这说明当字符串的值改变时，就会在内存中产生一个新的空间来存储新的对象，所以String在操作字符串时实质是在不断创建新的对象，原来的对象就会被GC掉，所以String在不断进行增删时效率低。下面来看字符串的截断（subString）方法的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">        if (beginIndex &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen = value.length - beginIndex;</span><br><span class="line">        if (subLen &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">       //当对原来的字符串进行截取的时候（beginIndex &gt;0），返回的结果是新建的对象</span><br><span class="line">        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer,StringBuilder都是继承抽象类AbstractStringBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//AbstractStringBuilder部分源码：</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The value is used for character storage.</span><br><span class="line">     */</span><br><span class="line">    char[] value;//一个char类型的数组，非final类型，这一点与String类不同</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * This no-arg constructor is necessary for serialization of subclasses.</span><br><span class="line">     */</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Creates an AbstractStringBuilder of the specified capacity.</span><br><span class="line">     */</span><br><span class="line">    AbstractStringBuilder(int capacity) &#123;</span><br><span class="line">        value = new char[capacity];//构建了长度为capacity大小的数组</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//其他代码省略……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出这个字符数组不是final类型，因此是可变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//SreingBuffer类的部分源码，因为StringBuilder构造函数实现方式差不多，所以就不贴了</span><br><span class="line">public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">   /**</span><br><span class="line">     * Constructs a string buffer with no characters in it and an</span><br><span class="line">     * initial capacity of 16 characters.</span><br><span class="line">     */</span><br><span class="line">    public StringBuffer() &#123;</span><br><span class="line">        super(16);//创建一个默认大小为16的char型数组</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Constructs a string buffer with no characters in it and</span><br><span class="line">     * the specified initial capacity.</span><br><span class="line">     *</span><br><span class="line">     * @param      capacity  the initial capacity.</span><br><span class="line">     * @exception  NegativeArraySizeException  if the &#123;@code capacity&#125;</span><br><span class="line">     *               argument is less than &#123;@code 0&#125;.</span><br><span class="line">     */</span><br><span class="line">    public StringBuffer(int capacity) &#123;</span><br><span class="line">        super(capacity);//自定义创建大小为capacity的char型数组</span><br><span class="line">    &#125;</span><br><span class="line">//省略其他代码……</span><br></pre></td></tr></table></figure><p>从源码可以看出，一开始的StringBuffer默认是分配16个字节的内存空间，当你通过append或者其他方法对StringBuffer对象进行修改，如果出现内存空间不足时，此时JVM会将空间扩充为（原本空间）*2+1个字节</p><p>StringBuffer与StringBuilder的主要区别是线程安全的问题<br>StringBuffer对调用的方法使用了同步锁，所以线程安全，而StringBuilder则没有。因为线程同步必定会消耗资源，所以StringBuilder的效率肯定会比StringBuffer高。实现同步是通过在方法前加上synchronized关键词。下面来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized StringBuffer reverse() &#123;</span><br><span class="line">    super.reverse();</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int indexOf(String str) &#123;</span><br><span class="line">    return indexOf(str, 0);</span><br></pre></td></tr></table></figure><p>Conclusions:<br>1.String类是不可变的，其余两个是可变的<br>2.String和StringBuffer是线程安全的，StringBuilder线程不安全<br>3.操作少量数据并且不频繁增删使用String，单线程操作大量数据使用StringBuilder，多线程下使用大量数据且需增删则使用StringBuffer<br>4.StringBuffer，StringBuilder常用方法，append方法是将内容追加到对象末尾，insert是在中间插入内容，toString()方法是将其余两个字符串类型转换为String类，delete(起始位置，结束位置)删除偏移字符串，length（）获取字符串长度</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2019/08/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/08/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>该篇主要叙述本人在编写代码时遇到的知识盲区，然后进行查阅资料所总结的</p><a id="more"></a><p>//Java抽象类：<br>由来：<br> 分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声    明，不抽取方法主体。 那么此方法就是一个抽象方法。<br> 比如我们要声明一个人类class，人类包含很多种，美国人和中国人。那么人类肯定会说话，但是说的是英语还是汉语需要具体的看是那种人，因为这个人类class   就可以声明为抽象类，声明一个说话的抽象方法，美国人和中国人分别继承然后重写说话的犯法实现自己的说话方式。<br> 1.抽象类是作为父类使用，内部可以有未实现的方法<br> 2.抽象类不可创建对象<br> 3.只有全部实现了抽象类的所有抽象方法，其子类才不为抽象类<br>基本格式：<br>public abstract 返回值类型 方法名（参数）{</p><p>}</p><p>//Java float,double赋值的区别<br>flaot a = 1.2; //错误，1.2默认为double类型，因此程序编译错误<br>flaot a = 1.2f; //正确<br>float a = 1;//正确，整形数据会自动转化为float类型<br>double a = 1;//正确<br>double a = 1.2//正确</p><p>//Java参数传递<br>Conclusions：<br>1.基本类型作为参数传递时，是值传递（在内存中新开辟空间拷贝原值），无论怎么改变方法中的值，都不会改变原值<br>2.当对象作为参数传递时，是把对象所在空间的地址拷贝给形参</p><p>For example：<br>1.基本类型（byte（8bit），short(2byte)，int(4byte)，long(8byte)，float(4byte)，double(8byte)，boolean(ibyte)，char(2byte)）作为参数传递：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">        int n = 3;</span><br><span class="line">        System.out.println(&quot;Before change, n = &quot; + n);</span><br><span class="line">        changeData(n);</span><br><span class="line">        System.out.println(&quot;After changeData(n), n = &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">       public static void changeData(int nn) &#123;</span><br><span class="line">        n = 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Answers:</span><br><span class="line">Before change, n = 3</span><br><span class="line">After changeData(n), n = 3</span><br></pre></td></tr></table></figure><p>2.对象作为参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(&quot;Hello &quot;);</span><br><span class="line">        System.out.println(&quot;Before change, sb = &quot; + sb);</span><br><span class="line">        changeData(sb);</span><br><span class="line">        System.out.println(&quot;After changeData(n), sb = &quot; + sb);</span><br><span class="line">    &#125;</span><br><span class="line">    //方法中进行没有对形参进行new操作</span><br><span class="line">       public static void changeData(StringBuffer strBuf) ；</span><br><span class="line">        strBuf.append(&quot;World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Answers:</span><br><span class="line">Before change, sb = Hello</span><br><span class="line">After changeData(n), sb = Hello World!</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(&quot;Hello &quot;);</span><br><span class="line">        System.out.println(&quot;Before change, sb = &quot; + sb);</span><br><span class="line">        changeData(sb);</span><br><span class="line">        System.out.println(&quot;After changeData(n), sb = &quot; + sb);</span><br><span class="line">    &#125;</span><br><span class="line">    //对形参进行new操作</span><br><span class="line">       public static void changeData(StringBuffer strBuf) &#123;</span><br><span class="line">           strBuf = new StringBuffer(&quot;Hi &quot;);</span><br><span class="line">           strBuf.append(&quot;World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Answers:</span><br><span class="line">Before change, sb = Hello</span><br><span class="line">After changeData(n), sb = Hello</span><br><span class="line">//当对形参进行new操作时，会重新申请一块内存，此时新申请对象所指向的空间变为新空间，所以当对new的对象进行修改时，不会影响原值</span><br></pre></td></tr></table></figure><p>String对象作形参时，也会申请<br>String类是个特殊的类，对它的一些操作符是重载的，如：<br>String str = “Hello”; 等价于String str = new String(“Hello”);<br>String str = “Hello”;<br>str = str + “ world!”;等价于str = new String((new StringBuffer(str)).append(“ world!”));<br>因此，你只要按上面的方法去分析，就会发现String对象和基本类型一样，一般情况下作为参数传递，在方法内改变了值，而原对象是不会被改变的。</p><p>例题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CardBoard &#123;</span><br><span class="line">  Short story = 5;</span><br><span class="line">  CardBoard go(CardBoard cb) &#123;</span><br><span class="line">    cb = null;</span><br><span class="line">    return cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    CardBoard c1 = new CardBoard();</span><br><span class="line">    CardBoard c2 = new CardBoard();</span><br><span class="line">    CardBoard c3 = c1.go(c2);</span><br><span class="line">    c1 = null;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">problem: 当这个程序执行完成后，c1，c2，c3一共有几个为null</span><br><span class="line">answer: 一共有两个，因为在执行go方法时，只是将c2的值，也就是c2所指向内存空间的地址传给cb，所以cb = null，不影响c2的值</span><br></pre></td></tr></table></figure><p>Java继承<br>this用于指向当前对象，super用于指向父类。<br>子类继承父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;</span><br><span class="line">  类名()&#123;</span><br><span class="line">    super();</span><br><span class="line">    对象的显示初始化;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类调用构造函数时，会先执行super进入父类的构造函数初始化父类，再返回子类的构造函数，将子类对象初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">    Fu()&#123;//构造函数</span><br><span class="line">        System.out.println(&quot;Fu!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   int num=4;</span><br><span class="line">   Zi() &#123;</span><br><span class="line">       System.out.println(&quot;Zi!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class extendsBasic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">Fu! </span><br><span class="line">Zi!</span><br></pre></td></tr></table></figure><p>当父类没有默认构造函数时（自定义类有参数的构造函数），在子类的构造函数内需要显示定义super(参数)，初始化父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">    Fu(int x)&#123;//构造函数有参数列表</span><br><span class="line">        System.out.println(&quot;Fu!&quot;+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   int num=4;</span><br><span class="line">   Zi() &#123;//子类的构造函数</span><br><span class="line">       //super()错误</span><br><span class="line">       super(8);//显式构造父类</span><br><span class="line">       System.out.println(&quot;Zi!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//但是如果子类是下面这样，则super()是正确的</span><br><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">    Fu(int x)&#123;//构造函数有参数列表</span><br><span class="line">        System.out.println(&quot;Fu!&quot;+x);</span><br><span class="line">    &#125;</span><br><span class="line">    Fu()&#123;//自定义无参构造函数</span><br><span class="line">       System.out.println(&quot;Fu!&quot;+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Zi z = new Zi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">     Fu(int x)&#123;//构造函数</span><br><span class="line">    this.num = x;</span><br><span class="line">        System.out.println(&quot;Fu!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     Fu() &#123;</span><br><span class="line">     System.out.println(&quot;Fu!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   int num=4;</span><br><span class="line">   Zi(int x) &#123;</span><br><span class="line">  this();</span><br><span class="line">       System.out.println(&quot;Zi!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   Zi()&#123;</span><br><span class="line">   System.out.println(&quot;Zi Zi!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">Fu！</span><br><span class="line">Zi Zi！</span><br><span class="line">当在子类构造函数中有this（）时，先调用this（），然后在到this（）方法中，调用super（），然后在执行显示定义</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Java在继承时，如果父类还有父类也会调用父类的父类的构造函数</span><br><span class="line">public class test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Fu f1 = new Fu();</span><br><span class="line">Fu f2 = new Zi();</span><br><span class="line">Fu f3 = new Sun();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;</span><br><span class="line">Fu()&#123;</span><br><span class="line">System.out.println(&quot;Fu!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line"> Zi()&#123;</span><br><span class="line"> System.out.println(&quot;Zi!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sun extends Zi&#123;</span><br><span class="line">Sun()&#123;</span><br><span class="line">System.out.println(&quot;Sun&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Fu!</span><br><span class="line">Fu!</span><br><span class="line">Zi!</span><br><span class="line">Fu!</span><br><span class="line">Zi!</span><br><span class="line">Sun</span><br></pre></td></tr></table></figure><p>Java多态：<br>Java有两种多态机制，一种是编译多态，一种是运行多态。编译多态是通过方法重载实现，后一种是通过方法覆盖实现。<br>样例一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">     Fu() &#123;</span><br><span class="line">     System.out.println(&quot;Fu!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void f() &#123;</span><br><span class="line">    System.out.println(&quot;Fu f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   int num=4;</span><br><span class="line">   public void f() &#123;</span><br><span class="line">   System.out.println(&quot;Zi f()&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Zi z = new Zi();</span><br><span class="line">    z.f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Fu！</span><br><span class="line">Zi f()</span><br></pre></td></tr></table></figure><p>从上面的样例可以看出，当子类重写f（）方法后会覆盖原来的f（）方法。在main函数中，new的对象实际上是Zi的对象，所以调用的f（）方法就是Zi类中的方法</p><p>当父类的构造函数中有调用方法时，构造函数内必须要声明和定义该方法，详情看下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">     Fu() &#123;</span><br><span class="line">     f();//当父类有该方法时，如何该类中没有定义，则会报语法错误</span><br><span class="line">     System.out.println(&quot;Fu!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//正确的写法</span><br><span class="line">class Fu&#123;</span><br><span class="line">    int num=3;</span><br><span class="line">     Fu() &#123;</span><br><span class="line">     f();//当父类有该方法时，如何该类中没有定义，则会报语法错误</span><br><span class="line">     System.out.println(&quot;Fu!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void f()&#123;</span><br><span class="line">      System.out.println(&quot;Fu f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样例二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Fu z = new Zi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;</span><br><span class="line">String a = &quot;Fu&quot;;</span><br><span class="line">     Fu() &#123;</span><br><span class="line">     f();</span><br><span class="line">    &#125;</span><br><span class="line">     void f() &#123;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   String a = &quot;Zi&quot;;</span><br><span class="line">    void f() &#123;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>从样例二可以看出，一个对象的创建过程，在new Zi()时，首先调用父类的构造函数，然后调用f()方法，由于子类重写了f()方法，所以调用的f方法是子类的，此时对象a还未赋值，所以输出字符串默认值null</p><p>样例三:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Fu z = new Zi();</span><br><span class="line">System.out.println(z.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;</span><br><span class="line">String a = &quot;Fu&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   String a = &quot;Zi&quot;;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Fu</span><br></pre></td></tr></table></figure><p>由样例三可以看出，类的成员变量不存在多态性，类的成员变量的值取决于所定义的变量类型，这是编译期间已经确定好的</p><p>样例四:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Fu z = new Zi();</span><br><span class="line">z.func1();</span><br><span class="line">z.func2();</span><br><span class="line">z.func3();//　错误，z对象中不存在func3方法，因为z对象被强制转换为Fu对象，所以不存在func3方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;</span><br><span class="line">public void func1() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void func2() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">   String a = &quot;Zi&quot;;</span><br><span class="line">   public void func1() &#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   public void func3() &#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java变量：<br>1.类变量，独立于方法之外的变量，static修饰<br>2.局部变量，方法内中的变量<br>3.实例变量，类的成员变量，独立于方法之外的变量，不用static修饰<br>权限访问修饰符<br>作用域    当前类    同一包    子孙类    其他包<br>public     √     √     √     √<br>protected     √     √     √     ×<br>default     √     √     ×     ×<br>private     √     ×     ×     ×</p><p>static:<br>1.可以修饰属性，变量，方法，内部类，代码段<br>2.初始化时在编译期间（类加载的时候），初始化后能够改变<br>3.修饰的属性在所有对象中都只有一个值<br>4.可以直接使用类名，不创建对象也可以调用修饰的属性，方法<br>5.不可以修饰局部变量</p><p>final:<br>1.可以修饰属性，变量，方法，内部类，代码段<br>2.初始化可在编辑期间也可以在运行期间，初始化后不可改变<br>3.修饰的属性于具体对象有关，在运行期间初始化的final对象，不同的对象可以有不同的值<br>4.final修饰的方法不能在子类中重写，修饰的类不能被继承</p><p>Java代码块:<br>一.静态代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">  static&#123;</span><br><span class="line">    System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1.静态代码块在类加载的时候就运行，且只会运行一次，并且优先级高于各种代码块以及构造函数，如有多个静态代码块，则按书写顺序一次执行。</span><br><span class="line">2.静态代码块不能存在任何方法体中，因为方法必须等待类加载完成并new出对象才可以通过对象使用，所以当方法体中不能有静态代码块</span><br><span class="line">3.同样的道理，静态代码块中也不能有普通变量</span><br><span class="line">*/</span><br><span class="line">``` </span><br><span class="line">二.静态代码块</span><br></pre></td></tr></table></figure><p>public class Test{<br>  {<br>    System.out.println(“构造代码块”);<br>  }<br>}<br>/*<br>1.构造代码块在创建每个对象时都会执行一次，但是优于构造函数执行。实质上构造代码块是依托于构造函数执行的，当在new对象时，实质上是调用构造函数，然后在构造函数里先执行构造代码块，然后执行下面的方法体<br>*/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三.普通代码块</span><br></pre></td></tr></table></figure><p>public class Test{<br>  public void test(){<br>    System.out.println(“”);</p><p>  }<br>}</p><pre><code>Java重载和重写重载:在同一个类中，多个方法拥有相同的名字，但名字相同的方法必须有不同的参数（参数个数，参数类型）。返回值类型，访问权限都不算重载重写:在子类继承父类时，子类重写的方法必须和父类方法的参数列表一样，返回值类型也必须一样，并且访问权限不能比父类中的访问权限小，如果父类方法抛出异常，则子类也必须抛出</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JVM内存管理</title>
      <link href="/2019/08/13/Java-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/13/Java-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java不像C++一样，需要程序员手动回收内存。所以当c++程序没有处理好内存回收，将会导致内存泄漏以及野指针（指针指向随机的内存空间，或者是以及删除的对象）等不良后果。Java拥有自动回收机制的JVM，所以对程序的安全性有很大保障。下面来讨论Java的JVM是怎么进行回收工作的。</p><a id="more"></a><p>一、JVM内存结构</p><img src="/2019/08/13/Java-JVM内存管理/1.jpeg" title="This is an image"><p>Java栈：<br>  Java栈是线程私有的，每个方法在执行的同时会创建一个栈。用于存储局部变量表，操作数栈，动态链接等信息。每一个方法调用到执行完成的过程，其实就是对应一个栈帧在虚拟机栈中入栈到出栈的过程<br>程序计数器：<br>  一块比较小的内存空间，可以看作是当前线程所执行的字节码行号指示，通俗的来说就是来指示下一条指令。因为Java的多线程是通过轮流切换来分配处理器的执行时间（表示一个时间段内只有一个线程是处于工作状态的），所以必须每个线程分配一个程序计数器，否则在线程频繁切换时，会导致线程不能正确的执行该线程的下一条指令。<br>Java堆：<br>  与Java栈不同的是，Java堆是所有线程共享的，用于存放对象的实例，几乎所有的对象都会在这里分配内存空间，从回收的角度看，Java堆可分为“新生代”和“老年带”。并且堆空间可以处于物理上的不连续空间，只需要逻辑上的连续即可。JDK1.6之前，字符串常量池位于方法区中，JDK1.7之后转移到Java堆。在Java虚拟机中实现字符串常量的是一个StringTable类，它的实质是一个Hash表。每个Java虚拟机中都只有一份这个Hash表，被所有的类共享。因此更多的数据要存放到堆中，导致堆大小要适配，所以更多的应用程序在堆中的使用差异更小。<br>方法区：<br>  方法区也是所有线程共享，它的主要功能存储虚拟机加载的类信息，常量和编译代码数据。方法区中有一个运行时常量池（注意不是字符串常量池），它存储的是类编译的各种字面量和符号引用。<br>     字面量：文本字符串，八种基本类型的值，final常量（表示成员变量只能被赋值一次，赋值后的值不再改变）<br>     符号引用：类和方法的全限定名（import org.apache.commons.lang3.StringUtils;boolean isEmpty = StringUtils.isNotEmpty(str)；） == （boolean isEmpty = org.springframework.util.StringUtils.isEmpty(str)/;）//全限定名，字段和方法的名称和描述符（static，final）</p><p>二、Java堆回收机制<br>垃圾回收主要考虑的问题有两个：一是效率问题，二是空间碎片问题<br>在前文中已经说过，Java堆有两个区域，“新生代”和“老年代”。新生代又分为三个部分，一个较大的Eden区域和两个Survivor区域。老年代就是一块大内存，没有分区但空间是零散的。因为新生代和老年代所存储的对象不同，为了把效率和碎片空间问题优化，所以两个区域采用不同的算法。<br>新生代-复制算法：<br>  新生代中主要存储比较新的对象，回收多次之后依然存活的对象会移动到老年代。由此可知新生代的垃圾回收比较频繁，复制算法可以将内存分为大小相同的两块，每次分配其中一块，当一块内存已满时，JVM将会对内存进行回收，将还存活的对象复制到其他一块内存，此时这块已满的内存就可以完全释放，不用担心碎片化的问题。这种算法的缺点是内存利用率较低，只能使用一般的内存进行分配。又因为有研究表明，新生代中的对象98%都会被释放，所以完全不用1:1的划分内存空间，所以最新的是将内存分为一块较大得Eden区和两块Survivor区。为什么需要两块Survivor呢，实质上是为了解决碎片化的问题，假定，只有一个Eden区，当该区满的时候，进行Gc（垃圾回收），存活对象放入Survivor区，清空Eden区，当第二次Gc时，有可能Survivor区内的部分对象失活，所以在清除Survivor区时，会出现内存碎片，当有两块Survivor区时可以避免这个问题。最终Java堆使用了两个Survivor区，一个from Survivor，一个to Survivor。第一次Eden满的时候，将存活对象放入from Survivor区，清空Eden。第二次Eden满的时候，将Eden和from Survivor区存活的对象放入to Survivor区，清空前两个区，然后将from Survivor 和 to Survivor互换。这样就解决了碎片化的问题</p><img src="/2019/08/13/Java-JVM内存管理/2.jpeg" title="This is an image"><p>老年代-整理标记法：<br>   由于老年代存放的是存活比较久的对象，所以老年代如果也采用复制法的话，会造成很大的内存开销，因为老年代中的对象基本都会存活。<br>   老年代的整理标记法首先将需要存活对象进行标记，然后让存活的对象想着一端移动按照内存地址依次排序，然后将末端内存地址回收。  </p><img src="/2019/08/13/Java-JVM内存管理/3.jpeg" title="This is an image"><p>方法区内存回收：<br> 方法区某些时候也叫“永久代”，因为该区存放的是类的信息以及一些常量信息。所以该区的内存难以回收。<br> 虽然方法区的垃圾回收效率低，但有些废弃常量和无用的类还是可以进行回收的。对于无用的类（该类所有实例都被回收，加载该类的ClassLoader也被回收，该类对象在任何地方都未引用）满足以上条件才有可能被回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc内存分配机制</title>
      <link href="/2019/08/09/malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/09/malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>malloc函数可用于动态分配内存，因为有时因为栈的空间较小，而程序所要求的内存空间较大，从而导致内存溢出，所以需要使用malloc函数在堆中申请内存。下面就来详细解释malloc函数是怎么样来分配内存的，并且我们要注意哪些问题。</p><a id="more"></a><p>一、堆在计算机中的存在形式<br>1.堆内存在内存中不是连续的，堆空间是由若干个小空间组合而成，在这里我们将每个小空间称为Heap。<br>2.每个Heap都由Header和可分配内存空间组成，Header是一种数据结构，包含这个Heap的一些信息，比如起始地址，空间大小，是否已经被分配，以及指向下一个Heap的指针等等。<br>3.这些Heap组成一个链表结构，用于保持Heap之间的联系。<br>4.一般都是使用指针的形式来访问Heap，不像栈空间可以使用变量名和指针两种形式访问。<br>二、malloc分配机制<br>当使用malloc分配内存时，计算机会依序从内存低地址到高地址开始搜索，直到搜索到一个Heap的可用内存空间大于或等于所需空间时，则将该Heap内存空间分为两部分，一部分用于分配，将该空间的起始地址返回给指针。另一部分将Header中的值修改重新加入Heap链表。为了便于free（）内存空间，经过malloc分配的堆空间也会有个Header来存储必要的信息。如果所有的Heap链中都没有满足的空间，则会返回NULL给指针。<br>这就意味着当有足够的空间可分配时，指针会被赋值地址，否则为NULL。<br>所以当我们使用malloc动态分配内存的时候我们要采用这种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *p = NULL;</span><br><span class="line">p = (char *)malloc(sizeof(char));</span><br><span class="line">if(p)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配成功后，得到的堆内存首地址一定要保存，否则会无法释放堆内存而造成内存泄露。而且不能使用未初始化指针所指向的内存空间。<br>三、指针操作堆空间<br>每当释放堆空间后（free）都应该将指针赋值为NULL。并且使用该指针指向的起始地址会有潜在危险（野指针）。<br>使用指针前判断其值是否为NULL<br>若malloc分配成功，则malloc前的强制类型转换规定链申请的堆空间要存的数据类型<br>四、free内存<br>free（）只是将指针指向的内存空间回收，其指针的值依然存在，所以需要手动置空。当释放未指向任何内存块的指针也会造成内存泄漏，所以在释放时应该先判断指针是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(p)&#123;</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br>malloc分配的堆内存结构为Header+内存空间，所以实际空间为sizeof（Header）+内存空间</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java文件处理</title>
      <link href="/2019/08/08/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2019/08/08/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java文件系统，包括目录，文件的创建，删除。读文件，写文件，java是采用数据流的形式来对文件进行读写</p><a id="more"></a><p>import java.io.*;<br>//文本文件<br>Java创建目录：<br>    File d = new File(“../../temp”);//路径../是返回上层，如果直接采用/temp则是在当前工程目录下创建<br>    if(!d.exists()) {<br>        d.mkdirs();//多级目录<br>        //d.mkdirs();单级目录<br>    }</p><p>Java创建文件：<br>    File f = new File(“../../temp/a.txt⁩”);<br>    //异常处理 try-catch<br>    if(!f.exists()) {<br>        try {<br>            f.createNewFile();//创建该文件（a.txt）<br>        }<br>        catch(Exception e) {<br>            e.printStackTrace();<br>        }</p><p>// 输出文件的相关属性<br>        System.out.println(“Is f file?” + f.isFile());<br>        System.out.println(“Name:” + f.getName());<br>        System.out.println(“Prarent:” + f.getParent());<br>        System.out.println(“Path:” + f.getPath());<br>        System.out.println(“Size:” + f.length() + “bytes”);<br>        System.out.println(“Last modified time:” + f.lastModified());</p><p>//目录，文件的删除<br>    f.delete();<br>    d.delete();</p><p>//写数据到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">OutputStreamWriter osw = null;</span><br><span class="line">BufferedWriter bw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    //节点类，负责写字节到文件</span><br><span class="line">    fos = new FileOutputStream(&quot;../../temp/a.txt&quot;);</span><br><span class="line">    //转化类，负责字符转化为字节</span><br><span class="line">    osw = new OutputStreamWriter(fos , &quot;UTF-8&quot;);</span><br><span class="line">    //装饰类，负责写字符到缓冲区</span><br><span class="line">    bw = new BufferedWriter(osw);</span><br><span class="line">    </span><br><span class="line">    bw.write(&quot;我们是&quot;);</span><br><span class="line">    //换行</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(&quot;Ecumers.^^&quot;);</span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //关闭自高层的类，底下流都会关闭</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//JDK7之后的try-resource语句，try语句结束后会自动关闭bw，更高效简洁</span><br><span class="line">try(BufferedWriter bw = </span><br><span class="line">new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;../../temp/b.txt&quot;))))&#123;</span><br><span class="line">bw.write(&quot;I am&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;ironman！&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    //读文件是只能逐行读取</span><br><span class="line">    public static void readFile() &#123;</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    InputStreamReader isr = null;</span><br><span class="line">    BufferedReader br = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        fis = new FileInputStream(&quot;../../temp/a.txt&quot;);</span><br><span class="line">        isr = new InputStreamReader(fis , &quot;UTF-8&quot;);</span><br><span class="line">        br = new BufferedReader(isr);</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null)</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //关闭自高层的类，底下流都会关闭</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;catch(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void readFile2() &#123;</span><br><span class="line">    try(BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;../../temp/b.txt&quot;))))&#123;</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//二进制文件读写</span><br><span class="line">//JDK7之前的写法</span><br><span class="line">    public static void binWriteFile() &#123;</span><br><span class="line">    FileOutputStream fos = null;</span><br><span class="line">    DataOutputStream dos = null;</span><br><span class="line">    BufferedOutputStream bos = null;</span><br><span class="line">    try &#123;</span><br><span class="line">    fos = new FileOutputStream (&quot;../../temp/b.dat&quot;);</span><br><span class="line">    bos = new BufferedOutputStream(fos);</span><br><span class="line">    dos = new DataOutputStream(bos);</span><br><span class="line">    </span><br><span class="line">    dos.writeUTF(&quot;a&quot;);</span><br><span class="line">    dos.writeInt(20);</span><br><span class="line">    dos.writeUTF(&quot;b&quot;);</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> //JDK7之后的try-source写法   </span><br><span class="line">    public static void binReadFile() &#123;</span><br><span class="line">    try(DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream(&quot;../../temp/b.dat&quot;))))&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(dis.readUTF());</span><br><span class="line">    System.out.println(dis.readInt());</span><br><span class="line">    System.out.println(dis.readUTF());</span><br><span class="line">    &#125;catch(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zip文件读写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//单文件压缩</span><br><span class="line">public static void oneFileZip() throws Exception&#123;</span><br><span class="line">//b.txt已经存在在temp目录下</span><br><span class="line">File file = new File(&quot;../../temp/a.txt&quot;);</span><br><span class="line">//a.zip不存在，只是定义压缩文件的名称</span><br><span class="line">File zipFile = new File(&quot;../../temp/a.zip&quot;);</span><br><span class="line">//定义文件的输入流</span><br><span class="line">InputStream input = new FileInputStream(file);</span><br><span class="line">//声明压缩流对象</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">//设置zipEntry对象,文件名称设置为原来的文件名，也可自行修改为其他例如（dd.txt）</span><br><span class="line">zos.putNextEntry(new ZipEntry(file.getName()));</span><br><span class="line">    //该程序采用每次读取一个字节，temp来记录一个字节的值</span><br><span class="line">int temp = 0;</span><br><span class="line">//当读到文件末尾时会返回-1</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line"> System.out.println(temp);</span><br><span class="line"> //将从a.txt中读出的数据写入zipEntry中</span><br><span class="line">     zos.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">zos.close();</span><br><span class="line">System.out.println(&quot;zip is finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//多文件压缩</span><br><span class="line">public static void multipleFileZip() throws Exception&#123;</span><br><span class="line">//打开一个准备压缩的目录</span><br><span class="line">File file = new File(&quot;../../temp&quot;);</span><br><span class="line">//压缩后的zip包名</span><br><span class="line">File zipFile = new File(&quot;../../test.zip&quot;);</span><br><span class="line">//定义文件输入数据流</span><br><span class="line">InputStream input = null;</span><br><span class="line">//定义压缩流</span><br><span class="line">ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile));</span><br><span class="line">//开始压缩</span><br><span class="line">int temp = 0;</span><br><span class="line">if(file.isDirectory()) &#123;</span><br><span class="line">//将该目录下所有的文件都存放到Lists数组</span><br><span class="line">File lists[] = file.listFiles();</span><br><span class="line">for(int i=0;i &lt; lists.length ;++i) &#123;</span><br><span class="line">//让input指向lists中的每个文件</span><br><span class="line">input = new FileInputStream(lists[i]);</span><br><span class="line">//设置zipEntry列表，按级取名</span><br><span class="line">zos.putNextEntry(new ZipEntry(file.getName() + File.separator + lists[i].getName()));</span><br><span class="line">System.out.println(&quot;正在压缩&quot;+lists[i].getName());</span><br><span class="line">//每次按一个字节压缩</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line">zos.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">zos.close();</span><br><span class="line">System.out.println(&quot;zip is finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//单文件解压</span><br><span class="line">    public static void oneFileUnzip() throws Exception&#123;</span><br><span class="line">File zipFile = new File(&quot;../../temp/a.zip&quot;);</span><br><span class="line">File outfile = new File(&quot;../../temp/dd.txt&quot;);</span><br><span class="line">ZipInputStream input = new ZipInputStream(new FileInputStream(zipFile));</span><br><span class="line">ZipEntry entry = input.getNextEntry();</span><br><span class="line">System.out.println(&quot;压缩实体名称&quot; + entry.getName());</span><br><span class="line"></span><br><span class="line">OutputStream out = new FileOutputStream(outfile);</span><br><span class="line">int temp = 0;</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line">out.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">out.close();</span><br><span class="line">System.out.println(&quot;unzip is finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//多文件解压</span><br><span class="line">public static void multipleFileUnzip() throws Exception&#123;</span><br><span class="line">//打开待解压的压缩包</span><br><span class="line">File file = new File(&quot;../../test.zip&quot;);</span><br><span class="line">//转化，将普通文件对象转化为压缩包实体对象</span><br><span class="line">ZipFile zipFile = new ZipFile(file);</span><br><span class="line">//将文件流转化为zip数据流</span><br><span class="line">ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file));</span><br><span class="line"></span><br><span class="line">OutputStream out = null;</span><br><span class="line">InputStream input = null;</span><br><span class="line">ZipEntry entry = null;</span><br><span class="line">//每次从压缩包中获取一个entry</span><br><span class="line">while((entry = zipInput.getNextEntry()) != null) &#123;</span><br><span class="line">System.out.println(&quot;解压缩&quot;+entry.getName());</span><br><span class="line">//输出文件的路径</span><br><span class="line">File outFile = new File(&quot;../../&quot;+entry.getName());</span><br><span class="line">//如果输出文件夹的上级路径不存在，则创建</span><br><span class="line">if(!outFile.getParentFile().exists()) &#123;</span><br><span class="line">outFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">//如果输出文件夹不存在，创建</span><br><span class="line">if(!outFile.exists()) &#123;</span><br><span class="line">//如果entry是一个目录，则压缩后依然是目录，则创建目录，如果是文件则创建文件</span><br><span class="line">if(entry.isDirectory()) &#123;</span><br><span class="line">outFile.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">outFile.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如果entry是一个文件，则将数据解压到文件</span><br><span class="line">if(!entry.isDirectory()) &#123;</span><br><span class="line">//得到entry实体的输入流</span><br><span class="line">input = zipFile.getInputStream(entry);</span><br><span class="line">//得到输出文件的输出流</span><br><span class="line">out = new FileOutputStream(outFile);</span><br><span class="line">int temp = 0;</span><br><span class="line">while((temp = input.read()) != -1) &#123;</span><br><span class="line">out.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用的数据结构</title>
      <link href="/2019/08/01/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/08/01/Java%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>关于Java的List（列表），Set（集合），++a和a++的具体区别</p><a id="more"></a><p>List：<br>ArrayList（可变数组）：基于数组的数据结构，遍历最好采用随机索引和foreach去遍历。尽量少用add，会造成大部分元素的移动，时间复杂度为O(n)，少添加和删除。<br>LinkedList：基于双向链表的数据结构，遍历最好采用迭代器和foreach去遍历，可以用add，链表的添加和删除都是O(1)<br>Vector：类似于ArraList，多一个遍历方法Emuration（类似于iterator）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//三种遍历方式</span><br><span class="line">public static void traverseByIterator(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========迭代器遍历=========&quot;);</span><br><span class="line">    Iterator&lt;Integer&gt;iter1 = a1.iterator();</span><br><span class="line">    while(iter1.hasNext()) &#123;</span><br><span class="line">    iter1.next();</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void traverseByIndex(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========随机索引遍历=========&quot;);</span><br><span class="line">    for(int i=0;i &lt; a1.size();++i) &#123;</span><br><span class="line">    a1.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void traverseByFor(ArrayList&lt;Integer&gt; a1)&#123;</span><br><span class="line">    long startTime = System.nanoTime();</span><br><span class="line">    System.out.println(&quot;=========For循环遍历=========&quot;);</span><br><span class="line">    for(Integer item : a1) &#123;</span><br><span class="line">    ;</span><br><span class="line">    &#125;</span><br><span class="line">    long endTime = System.nanoTime();</span><br><span class="line">    long duration = endTime - startTime;</span><br><span class="line">    System.out.println(duration+&quot;纳秒&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Set：<br>HashSet和LinkedHashSet的判断是根据hashCode和equals来进行判别两个是否对象是否相等，而TreeSet必须通过实现comparable接口里面的compareTo方法，否则会报语法错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class cat&#123;</span><br><span class="line">private int size;</span><br><span class="line">cat(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">    HashSet&lt;cat&gt;hs = new HashSet&lt;cat&gt;();</span><br><span class="line">    hs.add(new cat(1));</span><br><span class="line">    hs.add(new cat(1));</span><br><span class="line">    System.out.println(hs.size());</span><br><span class="line">//输出2   </span><br><span class="line"></span><br><span class="line">class dog&#123;</span><br><span class="line">private int size;</span><br><span class="line">dog(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">System.out.println(&quot;Dog hashCode&quot;);</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">/*该方法的参数必须是Object类型，如果为dog类型虽然不会报错，但输出结果会为2，equals方法不会被调用*/</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">System.out.println(&quot;Dog equals&quot;);</span><br><span class="line">if(0 == size - ((dog)obj).getSize())</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">System.out.println(&quot;Dog toString&quot;);</span><br><span class="line">return size + &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">        LinkedHashSet&lt;dog&gt;hs2 = new LinkedHashSet&lt;dog&gt;();</span><br><span class="line">hs2.add(new dog(1));</span><br><span class="line">hs2.add(new dog(1));</span><br><span class="line">System.out.println(hs2.size());</span><br><span class="line">//输出1</span><br><span class="line"></span><br><span class="line">//tiger类实现Comparable接口中的compareTo()方法</span><br><span class="line">class tiger implements Comparable&#123;</span><br><span class="line">private int size;</span><br><span class="line">tiger(int size)&#123;</span><br><span class="line">this.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int compareTo(Object obj) &#123;</span><br><span class="line">   return size - ((tiger)obj).getSize();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试，最后输出1</span><br><span class="line">        TreeSet&lt;tiger&gt; ts = new TreeSet&lt;tiger&gt;();</span><br><span class="line">ts.add(new tiger(1));</span><br><span class="line">ts.add(new tiger(1));</span><br><span class="line">System.out.println(ts.size());</span><br><span class="line"></span><br><span class="line">//如果写TreeSet&lt;dog&gt; ts = new TreeSet&lt;dog&gt;();会报语法错误</span><br></pre></td></tr></table></figure><p>a = 1：首先将常量1压入栈顶，后面将栈顶1弹出赋值给a，栈为空<br>a = a++：结果a = 1，因为a = a++是先将a的值1压入栈顶，再执行a+1操作，这时a的值为2，最后将栈顶的1弹出赋值给a，所以a=1；<br>a = ++a：结果a=2，因为a = ++a是先将a执行a+1操作，此时a等于，再将a的数值2压入栈顶，最后将2弹出并赋值给a，所以a=2</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="/2019/07/26/Dijkstra/"/>
      <url>/2019/07/26/Dijkstra/</url>
      
        <content type="html"><![CDATA[<p>单源最短路径：一个顶点到图中其它顶点的最短通路长度</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//顶点数为n，边数为m，该算法的时间复杂度为O(n^2)</span><br><span class="line">/*采用n*n矩阵存储数据,此代码是求顶点1到其他顶点的最短路，后面那个优化的是可以从任意顶点开始 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1e9</span><br><span class="line"></span><br><span class="line">static int Count = 2; //计数器判断算法结束</span><br><span class="line">int dis[10][10]; //矩阵存储数据</span><br><span class="line">bool flag[10] = &#123;0&#125;; //判断顶点是否已经访问过</span><br><span class="line">int range[10] = &#123;0&#125;;  // 存储源点到其他顶点的距离</span><br><span class="line">int res_record[10] = &#123;0,1,1,1,1,1,1,1,1,1&#125;; //记录从源点开始依次找到的点</span><br><span class="line"></span><br><span class="line">int MIN(int n)&#123;  //寻找最小距离的点</span><br><span class="line">    int t ;</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        if(flag[i]) continue;//所找到的点为已经找到的</span><br><span class="line">        else&#123;</span><br><span class="line">            t = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        if(range[t] &gt; range[i] &amp;&amp; !flag[i])&#123;</span><br><span class="line">            t = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">//点矩阵，距离矩阵的初始化</span><br><span class="line">void Init(int n)&#123;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">      dis[i][i] = MAX;</span><br><span class="line">   &#125; </span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       for(int j=1;j &lt; i ;++j)&#123;</span><br><span class="line">           cin &gt;&gt; dis[i][j];</span><br><span class="line">           dis[j][i] = dis[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">      range[i] = dis[1][i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> //每次找到一个点后对距离矩阵进行调整</span><br><span class="line">void Adjust(int i,int n)&#123;</span><br><span class="line">    for(int j=2;j &lt;= n;++j)&#123;</span><br><span class="line">        //判断依据是min(range[j],range[i]+dis[i][j])</span><br><span class="line">        if((!flag[j]) &amp;&amp; (range[j] &gt; range[i] + dis[i][j]))&#123;</span><br><span class="line">            //记录每个点的前驱</span><br><span class="line">           res_record[j] = i;</span><br><span class="line">           range[j] = range[i]+ dis[i][j];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int n)&#123;</span><br><span class="line">    while(Count &lt;= n)&#123;</span><br><span class="line">        //找到最小距离所对应的点</span><br><span class="line">        int t = MIN(n);</span><br><span class="line">        //判断该点是否以及被访问</span><br><span class="line">        if(!flag[t])&#123;</span><br><span class="line">           flag[t] = true;</span><br><span class="line">           Count++;</span><br><span class="line">           Adjust(t,n);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环查找最小距离所途经的点</span><br><span class="line">void find(int k)&#123;</span><br><span class="line">    int p = 0,t = 0;</span><br><span class="line">     while(k != 1)&#123;</span><br><span class="line">         range[t++] = k;</span><br><span class="line">         p += dis[k][res_record[k]];</span><br><span class="line">         k = res_record[k];</span><br><span class="line">     &#125;</span><br><span class="line">     range[t++] = 1;</span><br><span class="line">     for(int i=t-1;i &gt;= 1;--i)</span><br><span class="line">       cout &lt;&lt; range[i] &lt;&lt; &quot;--&gt;&quot;;</span><br><span class="line">       cout &lt;&lt; range[0] &lt;&lt; &quot;   &quot;&lt;&lt; &quot;距离:&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Init(n);</span><br><span class="line">    dijkstra(n);</span><br><span class="line">    for(int i=2;i &lt;= n;++i)&#123;</span><br><span class="line">        find(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法还可以进行改进，主要是在求最小range最小距离时可以使用最小堆（优先队列），可使复杂度降为O(nlog(n)) 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//采用n*n矩阵存储数据 </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1e9</span><br><span class="line">//小根堆</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    bool operator &lt; (const node &amp;a)const&#123;</span><br><span class="line">        return x &gt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static int Count = 2;</span><br><span class="line">int dis[10][10]; //矩阵存储数据</span><br><span class="line">int res_record[10] = &#123;0,1,1,1,1,1,1,1,1,1&#125;; //记录从源点开始依次找到的点</span><br><span class="line">priority_queue&lt;node&gt;Q;//优先队列</span><br><span class="line">vector&lt;node&gt;v;</span><br><span class="line"></span><br><span class="line">//点矩阵，距离矩阵的初始化</span><br><span class="line">void Init(int n,int m)&#123;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">      dis[i][i] = MAX;</span><br><span class="line">   &#125; </span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       for(int j=1;j &lt; i ;++j)&#123;</span><br><span class="line">           cin &gt;&gt; dis[i][j];</span><br><span class="line">           dis[j][i] = dis[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">       node a ;</span><br><span class="line">       a.x = dis[m][i];</span><br><span class="line">       a.y = i;</span><br><span class="line">       Q.push(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dijkstra(int n,int m)&#123;</span><br><span class="line">    while(Count &lt;= n)&#123;</span><br><span class="line">        //找到最小距离所对应的点</span><br><span class="line">        node a = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Count++;</span><br><span class="line">        while(!Q.empty())&#123;</span><br><span class="line">            node b = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">            if(b.x &gt; a.x + dis[a.y][b.y])&#123;</span><br><span class="line">                b.x = a.x + dis[a.y][b.y];</span><br><span class="line">                res_record[b.y] = a.y;</span><br><span class="line">            &#125;</span><br><span class="line">            v.push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i &lt; v.size();++i)&#123;</span><br><span class="line">            Q.push(v[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        v.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环查找最小距离所途经的点</span><br><span class="line">void find(int k,int m)&#123;</span><br><span class="line">    int p = 0,t = 1;</span><br><span class="line">    int record[10] = &#123;0&#125;;</span><br><span class="line">    record[0] = k;</span><br><span class="line">     while(k != m)&#123;</span><br><span class="line">         p += dis[k][res_record[k]];</span><br><span class="line">         k = res_record[k];</span><br><span class="line">         record[t++] = k;</span><br><span class="line">     &#125;</span><br><span class="line">     for(int i=t-1;i &gt;= 1;--i)&#123;</span><br><span class="line">         cout &lt;&lt; record[i] &lt;&lt; &quot;--&gt;&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">        cout &lt;&lt; record[0] &lt;&lt; &quot; 距离:  &quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //n个顶点，从第m个点出发</span><br><span class="line">    int n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">        res_record[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    Init(n,m); </span><br><span class="line">    dijkstra(n,m);</span><br><span class="line">    for(int i=1;i &lt;= n;++i)&#123;</span><br><span class="line">        if(m == i) continue;</span><br><span class="line">        find(i,m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
